/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Scheduler Public API (v1)
 * OpenAPI spec version: 1.3.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  BadRequestResponse,
  CommandRef,
  ConflictResponse,
  GetPackageParams,
  ListRunsParams,
  ListWorkers200,
  ListWorkersParams,
  ListWorkflowsParams,
  NotFoundResponse,
  PackageDetail,
  PackageList,
  Run,
  RunList,
  RunRef,
  RunStartRequest,
  Worker,
  WorkerCommand,
  Workflow,
  WorkflowList,
  WorkflowRef
} from './models';

/**
 * @summary List runs (paginated)
 */
export const listRuns = (
    params?: ListRunsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RunList>> => {
    
    
    return axios.default.get(
      `/api/v1/runs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getListRunsQueryKey = (params?: ListRunsParams,) => {
    return [
    `/api/v1/runs`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListRunsQueryOptions = <TData = Awaited<ReturnType<typeof listRuns>>, TError = AxiosError<unknown>>(params?: ListRunsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListRunsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listRuns>>> = ({ signal }) => listRuns(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListRunsQueryResult = NonNullable<Awaited<ReturnType<typeof listRuns>>>
export type ListRunsQueryError = AxiosError<unknown>


export function useListRuns<TData = Awaited<ReturnType<typeof listRuns>>, TError = AxiosError<unknown>>(
 params: undefined |  ListRunsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRuns>>,
          TError,
          Awaited<ReturnType<typeof listRuns>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListRuns<TData = Awaited<ReturnType<typeof listRuns>>, TError = AxiosError<unknown>>(
 params?: ListRunsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRuns>>,
          TError,
          Awaited<ReturnType<typeof listRuns>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListRuns<TData = Awaited<ReturnType<typeof listRuns>>, TError = AxiosError<unknown>>(
 params?: ListRunsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List runs (paginated)
 */

export function useListRuns<TData = Awaited<ReturnType<typeof listRuns>>, TError = AxiosError<unknown>>(
 params?: ListRunsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListRunsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Start a run using the in-memory workflow snapshot
 */
export const startRun = (
    runStartRequest: RunStartRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RunRef>> => {
    
    
    return axios.default.post(
      `/api/v1/runs`,
      runStartRequest,options
    );
  }



export const getStartRunMutationOptions = <TError = AxiosError<BadRequestResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startRun>>, TError,{data: RunStartRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof startRun>>, TError,{data: RunStartRequest}, TContext> => {

const mutationKey = ['startRun'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startRun>>, {data: RunStartRequest}> = (props) => {
          const {data} = props ?? {};

          return  startRun(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartRunMutationResult = NonNullable<Awaited<ReturnType<typeof startRun>>>
    export type StartRunMutationBody = RunStartRequest
    export type StartRunMutationError = AxiosError<BadRequestResponse | ConflictResponse>

    /**
 * @summary Start a run using the in-memory workflow snapshot
 */
export const useStartRun = <TError = AxiosError<BadRequestResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startRun>>, TError,{data: RunStartRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startRun>>,
        TError,
        {data: RunStartRequest},
        TContext
      > => {

      const mutationOptions = getStartRunMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get run summary
 */
export const getRun = (
    runId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Run>> => {
    
    
    return axios.default.get(
      `/api/v1/runs/${runId}`,options
    );
  }




export const getGetRunQueryKey = (runId?: string,) => {
    return [
    `/api/v1/runs/${runId}`
    ] as const;
    }

    
export const getGetRunQueryOptions = <TData = Awaited<ReturnType<typeof getRun>>, TError = AxiosError<NotFoundResponse>>(runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRun>>> = ({ signal }) => getRun(runId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRunQueryResult = NonNullable<Awaited<ReturnType<typeof getRun>>>
export type GetRunQueryError = AxiosError<NotFoundResponse>


export function useGetRun<TData = Awaited<ReturnType<typeof getRun>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRun>>,
          TError,
          Awaited<ReturnType<typeof getRun>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRun<TData = Awaited<ReturnType<typeof getRun>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRun>>,
          TError,
          Awaited<ReturnType<typeof getRun>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRun<TData = Awaited<ReturnType<typeof getRun>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get run summary
 */

export function useGetRun<TData = Awaited<ReturnType<typeof getRun>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRunQueryOptions(runId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get the immutable workflow snapshot used by this run
 */
export const getRunDefinition = (
    runId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Workflow>> => {
    
    
    return axios.default.get(
      `/api/v1/runs/${runId}/definition`,options
    );
  }




export const getGetRunDefinitionQueryKey = (runId?: string,) => {
    return [
    `/api/v1/runs/${runId}/definition`
    ] as const;
    }

    
export const getGetRunDefinitionQueryOptions = <TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = AxiosError<NotFoundResponse>>(runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunDefinitionQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunDefinition>>> = ({ signal }) => getRunDefinition(runId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRunDefinitionQueryResult = NonNullable<Awaited<ReturnType<typeof getRunDefinition>>>
export type GetRunDefinitionQueryError = AxiosError<NotFoundResponse>


export function useGetRunDefinition<TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRunDefinition>>,
          TError,
          Awaited<ReturnType<typeof getRunDefinition>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRunDefinition<TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRunDefinition>>,
          TError,
          Awaited<ReturnType<typeof getRunDefinition>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRunDefinition<TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get the immutable workflow snapshot used by this run
 */

export function useGetRunDefinition<TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRunDefinitionQueryOptions(runId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List stored workflows (paginated)
 */
export const listWorkflows = (
    params?: ListWorkflowsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WorkflowList>> => {
    
    
    return axios.default.get(
      `/api/v1/workflows`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getListWorkflowsQueryKey = (params?: ListWorkflowsParams,) => {
    return [
    `/api/v1/workflows`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListWorkflowsQueryOptions = <TData = Awaited<ReturnType<typeof listWorkflows>>, TError = AxiosError<unknown>>(params?: ListWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWorkflowsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWorkflows>>> = ({ signal }) => listWorkflows(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListWorkflowsQueryResult = NonNullable<Awaited<ReturnType<typeof listWorkflows>>>
export type ListWorkflowsQueryError = AxiosError<unknown>


export function useListWorkflows<TData = Awaited<ReturnType<typeof listWorkflows>>, TError = AxiosError<unknown>>(
 params: undefined |  ListWorkflowsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflows>>,
          TError,
          Awaited<ReturnType<typeof listWorkflows>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflows<TData = Awaited<ReturnType<typeof listWorkflows>>, TError = AxiosError<unknown>>(
 params?: ListWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflows>>,
          TError,
          Awaited<ReturnType<typeof listWorkflows>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflows<TData = Awaited<ReturnType<typeof listWorkflows>>, TError = AxiosError<unknown>>(
 params?: ListWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List stored workflows (paginated)
 */

export function useListWorkflows<TData = Awaited<ReturnType<typeof listWorkflows>>, TError = AxiosError<unknown>>(
 params?: ListWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListWorkflowsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Persist a workflow for editor storage (no versioning)
 */
export const persistWorkflow = (
    workflow: Workflow, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WorkflowRef>> => {
    
    
    return axios.default.post(
      `/api/v1/workflows`,
      workflow,options
    );
  }



export const getPersistWorkflowMutationOptions = <TError = AxiosError<BadRequestResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof persistWorkflow>>, TError,{data: Workflow}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof persistWorkflow>>, TError,{data: Workflow}, TContext> => {

const mutationKey = ['persistWorkflow'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof persistWorkflow>>, {data: Workflow}> = (props) => {
          const {data} = props ?? {};

          return  persistWorkflow(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PersistWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof persistWorkflow>>>
    export type PersistWorkflowMutationBody = Workflow
    export type PersistWorkflowMutationError = AxiosError<BadRequestResponse | ConflictResponse>

    /**
 * @summary Persist a workflow for editor storage (no versioning)
 */
export const usePersistWorkflow = <TError = AxiosError<BadRequestResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof persistWorkflow>>, TError,{data: Workflow}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof persistWorkflow>>,
        TError,
        {data: Workflow},
        TContext
      > => {

      const mutationOptions = getPersistWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Read stored workflow (latest)
 */
export const getWorkflow = (
    workflowId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Workflow>> => {
    
    
    return axios.default.get(
      `/api/v1/workflows/${workflowId}`,options
    );
  }




export const getGetWorkflowQueryKey = (workflowId?: string,) => {
    return [
    `/api/v1/workflows/${workflowId}`
    ] as const;
    }

    
export const getGetWorkflowQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflow>>, TError = AxiosError<NotFoundResponse>>(workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowQueryKey(workflowId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflow>>> = ({ signal }) => getWorkflow(workflowId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(workflowId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkflowQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflow>>>
export type GetWorkflowQueryError = AxiosError<NotFoundResponse>


export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = AxiosError<NotFoundResponse>>(
 workflowId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getWorkflow>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = AxiosError<NotFoundResponse>>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getWorkflow>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = AxiosError<NotFoundResponse>>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Read stored workflow (latest)
 */

export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = AxiosError<NotFoundResponse>>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkflowQueryOptions(workflowId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List available packages
 */
export const listPackages = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PackageList>> => {
    
    
    return axios.default.get(
      `/api/v1/packages`,options
    );
  }




export const getListPackagesQueryKey = () => {
    return [
    `/api/v1/packages`
    ] as const;
    }

    
export const getListPackagesQueryOptions = <TData = Awaited<ReturnType<typeof listPackages>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPackagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPackages>>> = ({ signal }) => listPackages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof listPackages>>>
export type ListPackagesQueryError = AxiosError<unknown>


export function useListPackages<TData = Awaited<ReturnType<typeof listPackages>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPackages>>,
          TError,
          Awaited<ReturnType<typeof listPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPackages<TData = Awaited<ReturnType<typeof listPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPackages>>,
          TError,
          Awaited<ReturnType<typeof listPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPackages<TData = Awaited<ReturnType<typeof listPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List available packages
 */

export function useListPackages<TData = Awaited<ReturnType<typeof listPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPackagesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get package detail
 */
export const getPackage = (
    packageName: string,
    params?: GetPackageParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PackageDetail>> => {
    
    
    return axios.default.get(
      `/api/v1/packages/${packageName}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetPackageQueryKey = (packageName?: string,
    params?: GetPackageParams,) => {
    return [
    `/api/v1/packages/${packageName}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetPackageQueryOptions = <TData = Awaited<ReturnType<typeof getPackage>>, TError = AxiosError<NotFoundResponse>>(packageName: string,
    params?: GetPackageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPackageQueryKey(packageName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPackage>>> = ({ signal }) => getPackage(packageName,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(packageName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPackageQueryResult = NonNullable<Awaited<ReturnType<typeof getPackage>>>
export type GetPackageQueryError = AxiosError<NotFoundResponse>


export function useGetPackage<TData = Awaited<ReturnType<typeof getPackage>>, TError = AxiosError<NotFoundResponse>>(
 packageName: string,
    params: undefined |  GetPackageParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPackage>>,
          TError,
          Awaited<ReturnType<typeof getPackage>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPackage<TData = Awaited<ReturnType<typeof getPackage>>, TError = AxiosError<NotFoundResponse>>(
 packageName: string,
    params?: GetPackageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPackage>>,
          TError,
          Awaited<ReturnType<typeof getPackage>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPackage<TData = Awaited<ReturnType<typeof getPackage>>, TError = AxiosError<NotFoundResponse>>(
 packageName: string,
    params?: GetPackageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get package detail
 */

export function useGetPackage<TData = Awaited<ReturnType<typeof getPackage>>, TError = AxiosError<NotFoundResponse>>(
 packageName: string,
    params?: GetPackageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPackageQueryOptions(packageName,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List workers (scheduler view)
 */
export const listWorkers = (
    params?: ListWorkersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListWorkers200>> => {
    
    
    return axios.default.get(
      `/api/v1/workers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getListWorkersQueryKey = (params?: ListWorkersParams,) => {
    return [
    `/api/v1/workers`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListWorkersQueryOptions = <TData = Awaited<ReturnType<typeof listWorkers>>, TError = AxiosError<unknown>>(params?: ListWorkersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWorkersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWorkers>>> = ({ signal }) => listWorkers(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListWorkersQueryResult = NonNullable<Awaited<ReturnType<typeof listWorkers>>>
export type ListWorkersQueryError = AxiosError<unknown>


export function useListWorkers<TData = Awaited<ReturnType<typeof listWorkers>>, TError = AxiosError<unknown>>(
 params: undefined |  ListWorkersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkers>>,
          TError,
          Awaited<ReturnType<typeof listWorkers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkers<TData = Awaited<ReturnType<typeof listWorkers>>, TError = AxiosError<unknown>>(
 params?: ListWorkersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkers>>,
          TError,
          Awaited<ReturnType<typeof listWorkers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkers<TData = Awaited<ReturnType<typeof listWorkers>>, TError = AxiosError<unknown>>(
 params?: ListWorkersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List workers (scheduler view)
 */

export function useListWorkers<TData = Awaited<ReturnType<typeof listWorkers>>, TError = AxiosError<unknown>>(
 params?: ListWorkersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListWorkersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get worker snapshot
 */
export const getWorker = (
    workerId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Worker>> => {
    
    
    return axios.default.get(
      `/api/v1/workers/${workerId}`,options
    );
  }




export const getGetWorkerQueryKey = (workerId?: string,) => {
    return [
    `/api/v1/workers/${workerId}`
    ] as const;
    }

    
export const getGetWorkerQueryOptions = <TData = Awaited<ReturnType<typeof getWorker>>, TError = AxiosError<NotFoundResponse>>(workerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkerQueryKey(workerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorker>>> = ({ signal }) => getWorker(workerId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(workerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkerQueryResult = NonNullable<Awaited<ReturnType<typeof getWorker>>>
export type GetWorkerQueryError = AxiosError<NotFoundResponse>


export function useGetWorker<TData = Awaited<ReturnType<typeof getWorker>>, TError = AxiosError<NotFoundResponse>>(
 workerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorker>>,
          TError,
          Awaited<ReturnType<typeof getWorker>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorker<TData = Awaited<ReturnType<typeof getWorker>>, TError = AxiosError<NotFoundResponse>>(
 workerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorker>>,
          TError,
          Awaited<ReturnType<typeof getWorker>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorker<TData = Awaited<ReturnType<typeof getWorker>>, TError = AxiosError<NotFoundResponse>>(
 workerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get worker snapshot
 */

export function useGetWorker<TData = Awaited<ReturnType<typeof getWorker>>, TError = AxiosError<NotFoundResponse>>(
 workerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkerQueryOptions(workerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Enqueue admin command (drain/rebind/pkg.install/pkg.uninstall)
 */
export const sendWorkerCommand = (
    workerId: string,
    workerCommand: WorkerCommand, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommandRef>> => {
    
    
    return axios.default.post(
      `/api/v1/workers/${workerId}/commands`,
      workerCommand,options
    );
  }



export const getSendWorkerCommandMutationOptions = <TError = AxiosError<BadRequestResponse | NotFoundResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendWorkerCommand>>, TError,{workerId: string;data: WorkerCommand}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sendWorkerCommand>>, TError,{workerId: string;data: WorkerCommand}, TContext> => {

const mutationKey = ['sendWorkerCommand'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendWorkerCommand>>, {workerId: string;data: WorkerCommand}> = (props) => {
          const {workerId,data} = props ?? {};

          return  sendWorkerCommand(workerId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendWorkerCommandMutationResult = NonNullable<Awaited<ReturnType<typeof sendWorkerCommand>>>
    export type SendWorkerCommandMutationBody = WorkerCommand
    export type SendWorkerCommandMutationError = AxiosError<BadRequestResponse | NotFoundResponse>

    /**
 * @summary Enqueue admin command (drain/rebind/pkg.install/pkg.uninstall)
 */
export const useSendWorkerCommand = <TError = AxiosError<BadRequestResponse | NotFoundResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendWorkerCommand>>, TError,{workerId: string;data: WorkerCommand}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendWorkerCommand>>,
        TError,
        {workerId: string;data: WorkerCommand},
        TContext
      > => {

      const mutationOptions = getSendWorkerCommandMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Global Server-Sent Events stream (firehose; no query parameters)
 */
export const sseGlobalEvents = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.get(
      `/api/v1/events`,{
        responseType: 'text',
    ...options,}
    );
  }




export const getSseGlobalEventsQueryKey = () => {
    return [
    `/api/v1/events`
    ] as const;
    }

    
export const getSseGlobalEventsQueryOptions = <TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSseGlobalEventsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sseGlobalEvents>>> = ({ signal }) => sseGlobalEvents({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SseGlobalEventsQueryResult = NonNullable<Awaited<ReturnType<typeof sseGlobalEvents>>>
export type SseGlobalEventsQueryError = AxiosError<unknown>


export function useSseGlobalEvents<TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sseGlobalEvents>>,
          TError,
          Awaited<ReturnType<typeof sseGlobalEvents>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSseGlobalEvents<TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sseGlobalEvents>>,
          TError,
          Awaited<ReturnType<typeof sseGlobalEvents>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSseGlobalEvents<TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Global Server-Sent Events stream (firehose; no query parameters)
 */

export function useSseGlobalEvents<TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSseGlobalEventsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
