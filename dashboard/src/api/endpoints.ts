/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Scheduler Public API (v1)
 * OpenAPI spec version: 1.3.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  AuditEventList,
  AuthLoginRequest,
  AuthLoginResponse,
  BadRequestResponse,
  CommandRef,
  ConflictResponse,
  CreateUserRequest,
  ForbiddenResponse,
  GetPackageParams,
  ListAuditEventsParams,
  ListRunsParams,
  ListWorkers200,
  ListWorkersParams,
  ListWorkflowPackagesParams,
  ListWorkflowsParams,
  NotFoundResponse,
  PackageDetail,
  PackageList,
  ResetUserPasswordRequest,
  Run,
  RunList,
  RunRef,
  RunStartRequest,
  SseGlobalEventsParams,
  UnauthorizedResponse,
  UpdateUserStatusRequest,
  UserList,
  UserRoleRequest,
  UserSummary,
  Worker,
  WorkerCommand,
  Workflow,
  WorkflowList,
  WorkflowPackageCloneRequest,
  WorkflowPackageDetail,
  WorkflowPackageList,
  WorkflowPackageVersionList,
  WorkflowPublishRequest,
  WorkflowPublishResponse,
  WorkflowRef
} from './models';

/**
 * @summary Exchange username/password for a JWT
 */
export const authLogin = (
    authLoginRequest: AuthLoginRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthLoginResponse>> => {
    
    
    return axios.default.post(
      `/api/v1/auth/login`,
      authLoginRequest,options
    );
  }



export const getAuthLoginMutationOptions = <TError = AxiosError<UnauthorizedResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginRequest}, TContext> => {

const mutationKey = ['authLogin'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authLogin>>, {data: AuthLoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  authLogin(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authLogin>>>
    export type AuthLoginMutationBody = AuthLoginRequest
    export type AuthLoginMutationError = AxiosError<UnauthorizedResponse>

    /**
 * @summary Exchange username/password for a JWT
 */
export const useAuthLogin = <TError = AxiosError<UnauthorizedResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authLogin>>,
        TError,
        {data: AuthLoginRequest},
        TContext
      > => {

      const mutationOptions = getAuthLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List runs (paginated)
 */
export const listRuns = (
    params?: ListRunsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RunList>> => {
    
    
    return axios.default.get(
      `/api/v1/runs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getListRunsQueryKey = (params?: ListRunsParams,) => {
    return [
    `/api/v1/runs`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListRunsQueryOptions = <TData = Awaited<ReturnType<typeof listRuns>>, TError = AxiosError<unknown>>(params?: ListRunsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListRunsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listRuns>>> = ({ signal }) => listRuns(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListRunsQueryResult = NonNullable<Awaited<ReturnType<typeof listRuns>>>
export type ListRunsQueryError = AxiosError<unknown>


export function useListRuns<TData = Awaited<ReturnType<typeof listRuns>>, TError = AxiosError<unknown>>(
 params: undefined |  ListRunsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRuns>>,
          TError,
          Awaited<ReturnType<typeof listRuns>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListRuns<TData = Awaited<ReturnType<typeof listRuns>>, TError = AxiosError<unknown>>(
 params?: ListRunsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRuns>>,
          TError,
          Awaited<ReturnType<typeof listRuns>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListRuns<TData = Awaited<ReturnType<typeof listRuns>>, TError = AxiosError<unknown>>(
 params?: ListRunsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List runs (paginated)
 */

export function useListRuns<TData = Awaited<ReturnType<typeof listRuns>>, TError = AxiosError<unknown>>(
 params?: ListRunsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListRunsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Start a run using the in-memory workflow snapshot
 */
export const startRun = (
    runStartRequest: RunStartRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RunRef>> => {
    
    
    return axios.default.post(
      `/api/v1/runs`,
      runStartRequest,options
    );
  }



export const getStartRunMutationOptions = <TError = AxiosError<BadRequestResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startRun>>, TError,{data: RunStartRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof startRun>>, TError,{data: RunStartRequest}, TContext> => {

const mutationKey = ['startRun'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startRun>>, {data: RunStartRequest}> = (props) => {
          const {data} = props ?? {};

          return  startRun(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartRunMutationResult = NonNullable<Awaited<ReturnType<typeof startRun>>>
    export type StartRunMutationBody = RunStartRequest
    export type StartRunMutationError = AxiosError<BadRequestResponse | ConflictResponse>

    /**
 * @summary Start a run using the in-memory workflow snapshot
 */
export const useStartRun = <TError = AxiosError<BadRequestResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startRun>>, TError,{data: RunStartRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startRun>>,
        TError,
        {data: RunStartRequest},
        TContext
      > => {

      const mutationOptions = getStartRunMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get run summary
 */
export const getRun = (
    runId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Run>> => {
    
    
    return axios.default.get(
      `/api/v1/runs/${runId}`,options
    );
  }




export const getGetRunQueryKey = (runId?: string,) => {
    return [
    `/api/v1/runs/${runId}`
    ] as const;
    }

    
export const getGetRunQueryOptions = <TData = Awaited<ReturnType<typeof getRun>>, TError = AxiosError<NotFoundResponse>>(runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRun>>> = ({ signal }) => getRun(runId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRunQueryResult = NonNullable<Awaited<ReturnType<typeof getRun>>>
export type GetRunQueryError = AxiosError<NotFoundResponse>


export function useGetRun<TData = Awaited<ReturnType<typeof getRun>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRun>>,
          TError,
          Awaited<ReturnType<typeof getRun>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRun<TData = Awaited<ReturnType<typeof getRun>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRun>>,
          TError,
          Awaited<ReturnType<typeof getRun>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRun<TData = Awaited<ReturnType<typeof getRun>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get run summary
 */

export function useGetRun<TData = Awaited<ReturnType<typeof getRun>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRunQueryOptions(runId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get the immutable workflow snapshot used by this run
 */
export const getRunDefinition = (
    runId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Workflow>> => {
    
    
    return axios.default.get(
      `/api/v1/runs/${runId}/definition`,options
    );
  }




export const getGetRunDefinitionQueryKey = (runId?: string,) => {
    return [
    `/api/v1/runs/${runId}/definition`
    ] as const;
    }

    
export const getGetRunDefinitionQueryOptions = <TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = AxiosError<NotFoundResponse>>(runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunDefinitionQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunDefinition>>> = ({ signal }) => getRunDefinition(runId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRunDefinitionQueryResult = NonNullable<Awaited<ReturnType<typeof getRunDefinition>>>
export type GetRunDefinitionQueryError = AxiosError<NotFoundResponse>


export function useGetRunDefinition<TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRunDefinition>>,
          TError,
          Awaited<ReturnType<typeof getRunDefinition>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRunDefinition<TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRunDefinition>>,
          TError,
          Awaited<ReturnType<typeof getRunDefinition>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRunDefinition<TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get the immutable workflow snapshot used by this run
 */

export function useGetRunDefinition<TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = AxiosError<NotFoundResponse>>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRunDefinitionQueryOptions(runId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List stored workflows (paginated)
 */
export const listWorkflows = (
    params?: ListWorkflowsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WorkflowList>> => {
    
    
    return axios.default.get(
      `/api/v1/workflows`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getListWorkflowsQueryKey = (params?: ListWorkflowsParams,) => {
    return [
    `/api/v1/workflows`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListWorkflowsQueryOptions = <TData = Awaited<ReturnType<typeof listWorkflows>>, TError = AxiosError<unknown>>(params?: ListWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWorkflowsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWorkflows>>> = ({ signal }) => listWorkflows(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListWorkflowsQueryResult = NonNullable<Awaited<ReturnType<typeof listWorkflows>>>
export type ListWorkflowsQueryError = AxiosError<unknown>


export function useListWorkflows<TData = Awaited<ReturnType<typeof listWorkflows>>, TError = AxiosError<unknown>>(
 params: undefined |  ListWorkflowsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflows>>,
          TError,
          Awaited<ReturnType<typeof listWorkflows>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflows<TData = Awaited<ReturnType<typeof listWorkflows>>, TError = AxiosError<unknown>>(
 params?: ListWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflows>>,
          TError,
          Awaited<ReturnType<typeof listWorkflows>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflows<TData = Awaited<ReturnType<typeof listWorkflows>>, TError = AxiosError<unknown>>(
 params?: ListWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List stored workflows (paginated)
 */

export function useListWorkflows<TData = Awaited<ReturnType<typeof listWorkflows>>, TError = AxiosError<unknown>>(
 params?: ListWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListWorkflowsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Persist a workflow for editor storage (no versioning)
 */
export const persistWorkflow = (
    workflow: Workflow, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WorkflowRef>> => {
    
    
    return axios.default.post(
      `/api/v1/workflows`,
      workflow,options
    );
  }



export const getPersistWorkflowMutationOptions = <TError = AxiosError<BadRequestResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof persistWorkflow>>, TError,{data: Workflow}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof persistWorkflow>>, TError,{data: Workflow}, TContext> => {

const mutationKey = ['persistWorkflow'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof persistWorkflow>>, {data: Workflow}> = (props) => {
          const {data} = props ?? {};

          return  persistWorkflow(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PersistWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof persistWorkflow>>>
    export type PersistWorkflowMutationBody = Workflow
    export type PersistWorkflowMutationError = AxiosError<BadRequestResponse | ConflictResponse>

    /**
 * @summary Persist a workflow for editor storage (no versioning)
 */
export const usePersistWorkflow = <TError = AxiosError<BadRequestResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof persistWorkflow>>, TError,{data: Workflow}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof persistWorkflow>>,
        TError,
        {data: Workflow},
        TContext
      > => {

      const mutationOptions = getPersistWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Read stored workflow (latest)
 */
export const getWorkflow = (
    workflowId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Workflow>> => {
    
    
    return axios.default.get(
      `/api/v1/workflows/${workflowId}`,options
    );
  }




export const getGetWorkflowQueryKey = (workflowId?: string,) => {
    return [
    `/api/v1/workflows/${workflowId}`
    ] as const;
    }

    
export const getGetWorkflowQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflow>>, TError = AxiosError<NotFoundResponse>>(workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowQueryKey(workflowId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflow>>> = ({ signal }) => getWorkflow(workflowId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(workflowId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkflowQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflow>>>
export type GetWorkflowQueryError = AxiosError<NotFoundResponse>


export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = AxiosError<NotFoundResponse>>(
 workflowId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getWorkflow>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = AxiosError<NotFoundResponse>>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getWorkflow>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = AxiosError<NotFoundResponse>>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Read stored workflow (latest)
 */

export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = AxiosError<NotFoundResponse>>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkflowQueryOptions(workflowId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Marks the workflow record as deleted so it is hidden from listings and future reads.
 * @summary Soft delete workflow
 */
export const deleteWorkflow = (
    workflowId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/workflows/${workflowId}`,options
    );
  }



export const getDeleteWorkflowMutationOptions = <TError = AxiosError<ForbiddenResponse | NotFoundResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflow>>, TError,{workflowId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflow>>, TError,{workflowId: string}, TContext> => {

const mutationKey = ['deleteWorkflow'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWorkflow>>, {workflowId: string}> = (props) => {
          const {workflowId} = props ?? {};

          return  deleteWorkflow(workflowId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWorkflow>>>
    
    export type DeleteWorkflowMutationError = AxiosError<ForbiddenResponse | NotFoundResponse>

    /**
 * @summary Soft delete workflow
 */
export const useDeleteWorkflow = <TError = AxiosError<ForbiddenResponse | NotFoundResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflow>>, TError,{workflowId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteWorkflow>>,
        TError,
        {workflowId: string},
        TContext
      > => {

      const mutationOptions = getDeleteWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete a workflow package
 */
export const deleteWorkflowPackage = (
    packageId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/workflow-packages/${packageId}`,options
    );
  }



export const getDeleteWorkflowPackageMutationOptions = <TError = AxiosError<ForbiddenResponse | NotFoundResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflowPackage>>, TError,{packageId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflowPackage>>, TError,{packageId: string}, TContext> => {

const mutationKey = ['deleteWorkflowPackage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWorkflowPackage>>, {packageId: string}> = (props) => {
          const {packageId} = props ?? {};

          return  deleteWorkflowPackage(packageId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteWorkflowPackageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWorkflowPackage>>>
    export type DeleteWorkflowPackageMutationError = AxiosError<ForbiddenResponse | NotFoundResponse>

    /**
 * @summary Delete a workflow package
 */
export const useDeleteWorkflowPackage = <TError = AxiosError<ForbiddenResponse | NotFoundResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflowPackage>>, TError,{packageId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteWorkflowPackage>>,
        TError,
        {packageId: string},
        TContext
      > => {

      const mutationOptions = getDeleteWorkflowPackageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List published workflow packages
 */
export const listWorkflowPackages = (
    params?: ListWorkflowPackagesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WorkflowPackageList>> => {
    
    
    return axios.default.get(
      `/api/v1/workflow-packages`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getListWorkflowPackagesQueryKey = (params?: ListWorkflowPackagesParams,) => {
    return [
    `/api/v1/workflow-packages`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListWorkflowPackagesQueryOptions = <TData = Awaited<ReturnType<typeof listWorkflowPackages>>, TError = AxiosError<unknown>>(params?: ListWorkflowPackagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWorkflowPackagesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWorkflowPackages>>> = ({ signal }) => listWorkflowPackages(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListWorkflowPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof listWorkflowPackages>>>
export type ListWorkflowPackagesQueryError = AxiosError<unknown>


export function useListWorkflowPackages<TData = Awaited<ReturnType<typeof listWorkflowPackages>>, TError = AxiosError<unknown>>(
 params: undefined |  ListWorkflowPackagesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflowPackages>>,
          TError,
          Awaited<ReturnType<typeof listWorkflowPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflowPackages<TData = Awaited<ReturnType<typeof listWorkflowPackages>>, TError = AxiosError<unknown>>(
 params?: ListWorkflowPackagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflowPackages>>,
          TError,
          Awaited<ReturnType<typeof listWorkflowPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflowPackages<TData = Awaited<ReturnType<typeof listWorkflowPackages>>, TError = AxiosError<unknown>>(
 params?: ListWorkflowPackagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List published workflow packages
 */

export function useListWorkflowPackages<TData = Awaited<ReturnType<typeof listWorkflowPackages>>, TError = AxiosError<unknown>>(
 params?: ListWorkflowPackagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListWorkflowPackagesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a workflow package detail
 */
export const getWorkflowPackage = (
    packageId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WorkflowPackageDetail>> => {
    
    
    return axios.default.get(
      `/api/v1/workflow-packages/${packageId}`,options
    );
  }




export const getGetWorkflowPackageQueryKey = (packageId?: string,) => {
    return [
    `/api/v1/workflow-packages/${packageId}`
    ] as const;
    }

    
export const getGetWorkflowPackageQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowPackage>>, TError = AxiosError<NotFoundResponse>>(packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPackage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowPackageQueryKey(packageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowPackage>>> = ({ signal }) => getWorkflowPackage(packageId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(packageId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPackage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkflowPackageQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowPackage>>>
export type GetWorkflowPackageQueryError = AxiosError<NotFoundResponse>


export function useGetWorkflowPackage<TData = Awaited<ReturnType<typeof getWorkflowPackage>>, TError = AxiosError<NotFoundResponse>>(
 packageId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPackage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPackage>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPackage>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflowPackage<TData = Awaited<ReturnType<typeof getWorkflowPackage>>, TError = AxiosError<NotFoundResponse>>(
 packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPackage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPackage>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPackage>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflowPackage<TData = Awaited<ReturnType<typeof getWorkflowPackage>>, TError = AxiosError<NotFoundResponse>>(
 packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPackage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a workflow package detail
 */

export function useGetWorkflowPackage<TData = Awaited<ReturnType<typeof getWorkflowPackage>>, TError = AxiosError<NotFoundResponse>>(
 packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPackage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkflowPackageQueryOptions(packageId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List versions for a workflow package
 */
export const listWorkflowPackageVersions = (
    packageId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WorkflowPackageVersionList>> => {
    
    
    return axios.default.get(
      `/api/v1/workflow-packages/${packageId}/versions`,options
    );
  }




export const getListWorkflowPackageVersionsQueryKey = (packageId?: string,) => {
    return [
    `/api/v1/workflow-packages/${packageId}/versions`
    ] as const;
    }

    
export const getListWorkflowPackageVersionsQueryOptions = <TData = Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError = AxiosError<NotFoundResponse>>(packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWorkflowPackageVersionsQueryKey(packageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWorkflowPackageVersions>>> = ({ signal }) => listWorkflowPackageVersions(packageId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(packageId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListWorkflowPackageVersionsQueryResult = NonNullable<Awaited<ReturnType<typeof listWorkflowPackageVersions>>>
export type ListWorkflowPackageVersionsQueryError = AxiosError<NotFoundResponse>


export function useListWorkflowPackageVersions<TData = Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError = AxiosError<NotFoundResponse>>(
 packageId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflowPackageVersions>>,
          TError,
          Awaited<ReturnType<typeof listWorkflowPackageVersions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflowPackageVersions<TData = Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError = AxiosError<NotFoundResponse>>(
 packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflowPackageVersions>>,
          TError,
          Awaited<ReturnType<typeof listWorkflowPackageVersions>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflowPackageVersions<TData = Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError = AxiosError<NotFoundResponse>>(
 packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List versions for a workflow package
 */

export function useListWorkflowPackageVersions<TData = Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError = AxiosError<NotFoundResponse>>(
 packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListWorkflowPackageVersionsQueryOptions(packageId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Clone a workflow package version into the caller's workspace
 */
export const cloneWorkflowPackage = (
    packageId: string,
    workflowPackageCloneRequest?: WorkflowPackageCloneRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WorkflowRef>> => {
    
    
    return axios.default.post(
      `/api/v1/workflow-packages/${packageId}/clone`,
      workflowPackageCloneRequest,options
    );
  }



export const getCloneWorkflowPackageMutationOptions = <TError = AxiosError<NotFoundResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cloneWorkflowPackage>>, TError,{packageId: string;data: WorkflowPackageCloneRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof cloneWorkflowPackage>>, TError,{packageId: string;data: WorkflowPackageCloneRequest}, TContext> => {

const mutationKey = ['cloneWorkflowPackage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cloneWorkflowPackage>>, {packageId: string;data: WorkflowPackageCloneRequest}> = (props) => {
          const {packageId,data} = props ?? {};

          return  cloneWorkflowPackage(packageId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CloneWorkflowPackageMutationResult = NonNullable<Awaited<ReturnType<typeof cloneWorkflowPackage>>>
    export type CloneWorkflowPackageMutationBody = WorkflowPackageCloneRequest
    export type CloneWorkflowPackageMutationError = AxiosError<NotFoundResponse>

    /**
 * @summary Clone a workflow package version into the caller's workspace
 */
export const useCloneWorkflowPackage = <TError = AxiosError<NotFoundResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cloneWorkflowPackage>>, TError,{packageId: string;data: WorkflowPackageCloneRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cloneWorkflowPackage>>,
        TError,
        {packageId: string;data: WorkflowPackageCloneRequest},
        TContext
      > => {

      const mutationOptions = getCloneWorkflowPackageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Publish a workflow draft to the Store
 */
export const publishWorkflow = (
    workflowId: string,
    workflowPublishRequest: WorkflowPublishRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WorkflowPublishResponse>> => {
    
    
    return axios.default.post(
      `/api/v1/workflows/${workflowId}/publish`,
      workflowPublishRequest,options
    );
  }



export const getPublishWorkflowMutationOptions = <TError = AxiosError<BadRequestResponse | ForbiddenResponse | NotFoundResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishWorkflow>>, TError,{workflowId: string;data: WorkflowPublishRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof publishWorkflow>>, TError,{workflowId: string;data: WorkflowPublishRequest}, TContext> => {

const mutationKey = ['publishWorkflow'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof publishWorkflow>>, {workflowId: string;data: WorkflowPublishRequest}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  publishWorkflow(workflowId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PublishWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof publishWorkflow>>>
    export type PublishWorkflowMutationBody = WorkflowPublishRequest
    export type PublishWorkflowMutationError = AxiosError<BadRequestResponse | ForbiddenResponse | NotFoundResponse | ConflictResponse>

    /**
 * @summary Publish a workflow draft to the Store
 */
export const usePublishWorkflow = <TError = AxiosError<BadRequestResponse | ForbiddenResponse | NotFoundResponse | ConflictResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishWorkflow>>, TError,{workflowId: string;data: WorkflowPublishRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof publishWorkflow>>,
        TError,
        {workflowId: string;data: WorkflowPublishRequest},
        TContext
      > => {

      const mutationOptions = getPublishWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List available packages
 */
export const listPackages = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PackageList>> => {
    
    
    return axios.default.get(
      `/api/v1/packages`,options
    );
  }




export const getListPackagesQueryKey = () => {
    return [
    `/api/v1/packages`
    ] as const;
    }

    
export const getListPackagesQueryOptions = <TData = Awaited<ReturnType<typeof listPackages>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPackagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPackages>>> = ({ signal }) => listPackages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof listPackages>>>
export type ListPackagesQueryError = AxiosError<unknown>


export function useListPackages<TData = Awaited<ReturnType<typeof listPackages>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPackages>>,
          TError,
          Awaited<ReturnType<typeof listPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPackages<TData = Awaited<ReturnType<typeof listPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPackages>>,
          TError,
          Awaited<ReturnType<typeof listPackages>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPackages<TData = Awaited<ReturnType<typeof listPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List available packages
 */

export function useListPackages<TData = Awaited<ReturnType<typeof listPackages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPackagesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get package detail
 */
export const getPackage = (
    packageName: string,
    params?: GetPackageParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PackageDetail>> => {
    
    
    return axios.default.get(
      `/api/v1/packages/${packageName}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetPackageQueryKey = (packageName?: string,
    params?: GetPackageParams,) => {
    return [
    `/api/v1/packages/${packageName}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetPackageQueryOptions = <TData = Awaited<ReturnType<typeof getPackage>>, TError = AxiosError<NotFoundResponse>>(packageName: string,
    params?: GetPackageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPackageQueryKey(packageName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPackage>>> = ({ signal }) => getPackage(packageName,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(packageName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPackageQueryResult = NonNullable<Awaited<ReturnType<typeof getPackage>>>
export type GetPackageQueryError = AxiosError<NotFoundResponse>


export function useGetPackage<TData = Awaited<ReturnType<typeof getPackage>>, TError = AxiosError<NotFoundResponse>>(
 packageName: string,
    params: undefined |  GetPackageParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPackage>>,
          TError,
          Awaited<ReturnType<typeof getPackage>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPackage<TData = Awaited<ReturnType<typeof getPackage>>, TError = AxiosError<NotFoundResponse>>(
 packageName: string,
    params?: GetPackageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPackage>>,
          TError,
          Awaited<ReturnType<typeof getPackage>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPackage<TData = Awaited<ReturnType<typeof getPackage>>, TError = AxiosError<NotFoundResponse>>(
 packageName: string,
    params?: GetPackageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get package detail
 */

export function useGetPackage<TData = Awaited<ReturnType<typeof getPackage>>, TError = AxiosError<NotFoundResponse>>(
 packageName: string,
    params?: GetPackageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPackageQueryOptions(packageName,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List workers (scheduler view)
 */
export const listWorkers = (
    params?: ListWorkersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListWorkers200>> => {
    
    
    return axios.default.get(
      `/api/v1/workers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getListWorkersQueryKey = (params?: ListWorkersParams,) => {
    return [
    `/api/v1/workers`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListWorkersQueryOptions = <TData = Awaited<ReturnType<typeof listWorkers>>, TError = AxiosError<unknown>>(params?: ListWorkersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWorkersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWorkers>>> = ({ signal }) => listWorkers(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListWorkersQueryResult = NonNullable<Awaited<ReturnType<typeof listWorkers>>>
export type ListWorkersQueryError = AxiosError<unknown>


export function useListWorkers<TData = Awaited<ReturnType<typeof listWorkers>>, TError = AxiosError<unknown>>(
 params: undefined |  ListWorkersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkers>>,
          TError,
          Awaited<ReturnType<typeof listWorkers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkers<TData = Awaited<ReturnType<typeof listWorkers>>, TError = AxiosError<unknown>>(
 params?: ListWorkersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkers>>,
          TError,
          Awaited<ReturnType<typeof listWorkers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkers<TData = Awaited<ReturnType<typeof listWorkers>>, TError = AxiosError<unknown>>(
 params?: ListWorkersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List workers (scheduler view)
 */

export function useListWorkers<TData = Awaited<ReturnType<typeof listWorkers>>, TError = AxiosError<unknown>>(
 params?: ListWorkersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListWorkersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get worker snapshot
 */
export const getWorker = (
    workerId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Worker>> => {
    
    
    return axios.default.get(
      `/api/v1/workers/${workerId}`,options
    );
  }




export const getGetWorkerQueryKey = (workerId?: string,) => {
    return [
    `/api/v1/workers/${workerId}`
    ] as const;
    }

    
export const getGetWorkerQueryOptions = <TData = Awaited<ReturnType<typeof getWorker>>, TError = AxiosError<NotFoundResponse>>(workerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkerQueryKey(workerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorker>>> = ({ signal }) => getWorker(workerId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(workerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkerQueryResult = NonNullable<Awaited<ReturnType<typeof getWorker>>>
export type GetWorkerQueryError = AxiosError<NotFoundResponse>


export function useGetWorker<TData = Awaited<ReturnType<typeof getWorker>>, TError = AxiosError<NotFoundResponse>>(
 workerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorker>>,
          TError,
          Awaited<ReturnType<typeof getWorker>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorker<TData = Awaited<ReturnType<typeof getWorker>>, TError = AxiosError<NotFoundResponse>>(
 workerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorker>>,
          TError,
          Awaited<ReturnType<typeof getWorker>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorker<TData = Awaited<ReturnType<typeof getWorker>>, TError = AxiosError<NotFoundResponse>>(
 workerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get worker snapshot
 */

export function useGetWorker<TData = Awaited<ReturnType<typeof getWorker>>, TError = AxiosError<NotFoundResponse>>(
 workerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkerQueryOptions(workerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Enqueue admin command (drain/rebind/pkg.install/pkg.uninstall)
 */
export const sendWorkerCommand = (
    workerId: string,
    workerCommand: WorkerCommand, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommandRef>> => {
    
    
    return axios.default.post(
      `/api/v1/workers/${workerId}/commands`,
      workerCommand,options
    );
  }



export const getSendWorkerCommandMutationOptions = <TError = AxiosError<BadRequestResponse | NotFoundResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendWorkerCommand>>, TError,{workerId: string;data: WorkerCommand}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sendWorkerCommand>>, TError,{workerId: string;data: WorkerCommand}, TContext> => {

const mutationKey = ['sendWorkerCommand'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendWorkerCommand>>, {workerId: string;data: WorkerCommand}> = (props) => {
          const {workerId,data} = props ?? {};

          return  sendWorkerCommand(workerId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendWorkerCommandMutationResult = NonNullable<Awaited<ReturnType<typeof sendWorkerCommand>>>
    export type SendWorkerCommandMutationBody = WorkerCommand
    export type SendWorkerCommandMutationError = AxiosError<BadRequestResponse | NotFoundResponse>

    /**
 * @summary Enqueue admin command (drain/rebind/pkg.install/pkg.uninstall)
 */
export const useSendWorkerCommand = <TError = AxiosError<BadRequestResponse | NotFoundResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendWorkerCommand>>, TError,{workerId: string;data: WorkerCommand}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendWorkerCommand>>,
        TError,
        {workerId: string;data: WorkerCommand},
        TContext
      > => {

      const mutationOptions = getSendWorkerCommandMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Global Server-Sent Events stream (firehose; no query parameters)
 */
export const sseGlobalEvents = (
    params: SseGlobalEventsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.get(
      `/api/v1/events`,{
        responseType: 'text',
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getSseGlobalEventsQueryKey = (params?: SseGlobalEventsParams,) => {
    return [
    `/api/v1/events`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSseGlobalEventsQueryOptions = <TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = AxiosError<unknown>>(params: SseGlobalEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSseGlobalEventsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sseGlobalEvents>>> = ({ signal }) => sseGlobalEvents(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SseGlobalEventsQueryResult = NonNullable<Awaited<ReturnType<typeof sseGlobalEvents>>>
export type SseGlobalEventsQueryError = AxiosError<unknown>


export function useSseGlobalEvents<TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = AxiosError<unknown>>(
 params: SseGlobalEventsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sseGlobalEvents>>,
          TError,
          Awaited<ReturnType<typeof sseGlobalEvents>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSseGlobalEvents<TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = AxiosError<unknown>>(
 params: SseGlobalEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sseGlobalEvents>>,
          TError,
          Awaited<ReturnType<typeof sseGlobalEvents>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSseGlobalEvents<TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = AxiosError<unknown>>(
 params: SseGlobalEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Global Server-Sent Events stream (firehose; no query parameters)
 */

export function useSseGlobalEvents<TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = AxiosError<unknown>>(
 params: SseGlobalEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSseGlobalEventsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List users and their roles
 */
export const listUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserList>> => {
    
    
    return axios.default.get(
      `/api/v1/users`,options
    );
  }




export const getListUsersQueryKey = () => {
    return [
    `/api/v1/users`
    ] as const;
    }

    
export const getListUsersQueryOptions = <TData = Awaited<ReturnType<typeof listUsers>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsers>>> = ({ signal }) => listUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListUsersQueryResult = NonNullable<Awaited<ReturnType<typeof listUsers>>>
export type ListUsersQueryError = AxiosError<unknown>


export function useListUsers<TData = Awaited<ReturnType<typeof listUsers>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListUsers<TData = Awaited<ReturnType<typeof listUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListUsers<TData = Awaited<ReturnType<typeof listUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List users and their roles
 */

export function useListUsers<TData = Awaited<ReturnType<typeof listUsers>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new user
 */
export const createUser = (
    createUserRequest: CreateUserRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSummary>> => {
    
    
    return axios.default.post(
      `/api/v1/users`,
      createUserRequest,options
    );
  }



export const getCreateUserMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserRequest}, TContext> => {

const mutationKey = ['createUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: CreateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = CreateUserRequest
    export type CreateUserMutationError = AxiosError<unknown>

    /**
 * @summary Create a new user
 */
export const useCreateUser = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: CreateUserRequest},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Reset user password
 */
export const resetUserPassword = (
    userId: string,
    resetUserPasswordRequest: ResetUserPasswordRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/api/v1/users/${userId}/password`,
      resetUserPasswordRequest,options
    );
  }



export const getResetUserPasswordMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetUserPassword>>, TError,{userId: string;data: ResetUserPasswordRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof resetUserPassword>>, TError,{userId: string;data: ResetUserPasswordRequest}, TContext> => {

const mutationKey = ['resetUserPassword'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetUserPassword>>, {userId: string;data: ResetUserPasswordRequest}> = (props) => {
          const {userId,data} = props ?? {};

          return  resetUserPassword(userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetUserPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof resetUserPassword>>>
    export type ResetUserPasswordMutationBody = ResetUserPasswordRequest
    export type ResetUserPasswordMutationError = AxiosError<unknown>

    /**
 * @summary Reset user password
 */
export const useResetUserPassword = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetUserPassword>>, TError,{userId: string;data: ResetUserPasswordRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetUserPassword>>,
        TError,
        {userId: string;data: ResetUserPasswordRequest},
        TContext
      > => {

      const mutationOptions = getResetUserPasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Assign role to user
 */
export const addUserRole = (
    userId: string,
    userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/api/v1/users/${userId}/roles`,
      userRoleRequest,options
    );
  }



export const getAddUserRoleMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addUserRole>>, TError,{userId: string;data: UserRoleRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addUserRole>>, TError,{userId: string;data: UserRoleRequest}, TContext> => {

const mutationKey = ['addUserRole'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addUserRole>>, {userId: string;data: UserRoleRequest}> = (props) => {
          const {userId,data} = props ?? {};

          return  addUserRole(userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddUserRoleMutationResult = NonNullable<Awaited<ReturnType<typeof addUserRole>>>
    export type AddUserRoleMutationBody = UserRoleRequest
    export type AddUserRoleMutationError = AxiosError<unknown>

    /**
 * @summary Assign role to user
 */
export const useAddUserRole = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addUserRole>>, TError,{userId: string;data: UserRoleRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addUserRole>>,
        TError,
        {userId: string;data: UserRoleRequest},
        TContext
      > => {

      const mutationOptions = getAddUserRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Remove role from user
 */
export const removeUserRole = (
    userId: string,
    role: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/users/${userId}/roles/${role}`,options
    );
  }



export const getRemoveUserRoleMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUserRole>>, TError,{userId: string;role: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeUserRole>>, TError,{userId: string;role: string}, TContext> => {

const mutationKey = ['removeUserRole'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUserRole>>, {userId: string;role: string}> = (props) => {
          const {userId,role} = props ?? {};

          return  removeUserRole(userId,role,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveUserRoleMutationResult = NonNullable<Awaited<ReturnType<typeof removeUserRole>>>
    
    export type RemoveUserRoleMutationError = AxiosError<unknown>

    /**
 * @summary Remove role from user
 */
export const useRemoveUserRole = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUserRole>>, TError,{userId: string;role: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeUserRole>>,
        TError,
        {userId: string;role: string},
        TContext
      > => {

      const mutationOptions = getRemoveUserRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Toggle user active state
 */
export const updateUserStatus = (
    userId: string,
    updateUserStatusRequest: UpdateUserStatusRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.patch(
      `/api/v1/users/${userId}/status`,
      updateUserStatusRequest,options
    );
  }



export const getUpdateUserStatusMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserStatus>>, TError,{userId: string;data: UpdateUserStatusRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserStatus>>, TError,{userId: string;data: UpdateUserStatusRequest}, TContext> => {

const mutationKey = ['updateUserStatus'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserStatus>>, {userId: string;data: UpdateUserStatusRequest}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUserStatus(userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserStatus>>>
    export type UpdateUserStatusMutationBody = UpdateUserStatusRequest
    export type UpdateUserStatusMutationError = AxiosError<unknown>

    /**
 * @summary Toggle user active state
 */
export const useUpdateUserStatus = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserStatus>>, TError,{userId: string;data: UpdateUserStatusRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUserStatus>>,
        TError,
        {userId: string;data: UpdateUserStatusRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List audit events
 */
export const listAuditEvents = (
    params?: ListAuditEventsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuditEventList>> => {
    
    
    return axios.default.get(
      `/api/v1/audit-events`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getListAuditEventsQueryKey = (params?: ListAuditEventsParams,) => {
    return [
    `/api/v1/audit-events`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAuditEventsQueryOptions = <TData = Awaited<ReturnType<typeof listAuditEvents>>, TError = AxiosError<unknown>>(params?: ListAuditEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAuditEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAuditEventsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAuditEvents>>> = ({ signal }) => listAuditEvents(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAuditEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAuditEventsQueryResult = NonNullable<Awaited<ReturnType<typeof listAuditEvents>>>
export type ListAuditEventsQueryError = AxiosError<unknown>


export function useListAuditEvents<TData = Awaited<ReturnType<typeof listAuditEvents>>, TError = AxiosError<unknown>>(
 params: undefined |  ListAuditEventsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAuditEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAuditEvents>>,
          TError,
          Awaited<ReturnType<typeof listAuditEvents>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAuditEvents<TData = Awaited<ReturnType<typeof listAuditEvents>>, TError = AxiosError<unknown>>(
 params?: ListAuditEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAuditEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAuditEvents>>,
          TError,
          Awaited<ReturnType<typeof listAuditEvents>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAuditEvents<TData = Awaited<ReturnType<typeof listAuditEvents>>, TError = AxiosError<unknown>>(
 params?: ListAuditEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAuditEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List audit events
 */

export function useListAuditEvents<TData = Awaited<ReturnType<typeof listAuditEvents>>, TError = AxiosError<unknown>>(
 params?: ListAuditEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAuditEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAuditEventsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
