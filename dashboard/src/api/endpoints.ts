/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * Scheduler Public API (v1)
 * OpenAPI spec version: 1.3.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AuditEventList,
  AuthLoginRequest,
  AuthLoginResponse,
  BadRequestResponse,
  CatalogNodeSearchResponse,
  CommandRef,
  ConflictResponse,
  CreateUserRequest,
  ForbiddenResponse,
  GetPackageParams,
  ListAuditEventsParams,
  ListRunsParams,
  ListWorkers200,
  ListWorkersParams,
  ListWorkflowPackagesParams,
  ListWorkflowsParams,
  NotFoundResponse,
  PackageDetail,
  PackageList,
  ResetUserPasswordRequest,
  Run,
  RunList,
  RunRef,
  RunStartRequest,
  SearchCatalogNodesParams,
  SseGlobalEventsParams,
  UnauthorizedResponse,
  UpdateUserStatusRequest,
  UserList,
  UserRoleRequest,
  UserSummary,
  Worker,
  WorkerCommand,
  Workflow,
  WorkflowList,
  WorkflowPackageCloneRequest,
  WorkflowPackageDetail,
  WorkflowPackageList,
  WorkflowPackageVersionList,
  WorkflowPreview,
  WorkflowPublishRequest,
  WorkflowPublishResponse,
  WorkflowRef
} from './models';

import { client } from '../lib/httpClient';
/**
 * @summary Exchange username/password for a JWT
 */
export const authLogin = (
    authLoginRequest: AuthLoginRequest,
 signal?: AbortSignal
) => {
      
      
      return client<AuthLoginResponse>(
      {url: `/api/v1/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: authLoginRequest, signal
    },
      );
    }
  


export const getAuthLoginMutationOptions = <TError = UnauthorizedResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginRequest}, TContext> => {

const mutationKey = ['authLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authLogin>>, {data: AuthLoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  authLogin(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authLogin>>>
    export type AuthLoginMutationBody = AuthLoginRequest
    export type AuthLoginMutationError = UnauthorizedResponse

    /**
 * @summary Exchange username/password for a JWT
 */
export const useAuthLogin = <TError = UnauthorizedResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authLogin>>, TError,{data: AuthLoginRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authLogin>>,
        TError,
        {data: AuthLoginRequest},
        TContext
      > => {

      const mutationOptions = getAuthLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List runs (paginated)
 */
export const listRuns = (
    params?: ListRunsParams,
 signal?: AbortSignal
) => {
      
      
      return client<RunList>(
      {url: `/api/v1/runs`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListRunsQueryKey = (params?: ListRunsParams,) => {
    return [
    `/api/v1/runs`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListRunsQueryOptions = <TData = Awaited<ReturnType<typeof listRuns>>, TError = unknown>(params?: ListRunsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListRunsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listRuns>>> = ({ signal }) => listRuns(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListRunsQueryResult = NonNullable<Awaited<ReturnType<typeof listRuns>>>
export type ListRunsQueryError = unknown


export function useListRuns<TData = Awaited<ReturnType<typeof listRuns>>, TError = unknown>(
 params: undefined |  ListRunsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRuns>>,
          TError,
          Awaited<ReturnType<typeof listRuns>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListRuns<TData = Awaited<ReturnType<typeof listRuns>>, TError = unknown>(
 params?: ListRunsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRuns>>,
          TError,
          Awaited<ReturnType<typeof listRuns>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListRuns<TData = Awaited<ReturnType<typeof listRuns>>, TError = unknown>(
 params?: ListRunsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List runs (paginated)
 */

export function useListRuns<TData = Awaited<ReturnType<typeof listRuns>>, TError = unknown>(
 params?: ListRunsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRuns>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListRunsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Start a run using the in-memory workflow snapshot
 */
export const startRun = (
    runStartRequest: RunStartRequest,
 signal?: AbortSignal
) => {
      
      
      return client<RunRef>(
      {url: `/api/v1/runs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: runStartRequest, signal
    },
      );
    }
  


export const getStartRunMutationOptions = <TError = BadRequestResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startRun>>, TError,{data: RunStartRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof startRun>>, TError,{data: RunStartRequest}, TContext> => {

const mutationKey = ['startRun'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startRun>>, {data: RunStartRequest}> = (props) => {
          const {data} = props ?? {};

          return  startRun(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartRunMutationResult = NonNullable<Awaited<ReturnType<typeof startRun>>>
    export type StartRunMutationBody = RunStartRequest
    export type StartRunMutationError = BadRequestResponse | ConflictResponse

    /**
 * @summary Start a run using the in-memory workflow snapshot
 */
export const useStartRun = <TError = BadRequestResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startRun>>, TError,{data: RunStartRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startRun>>,
        TError,
        {data: RunStartRequest},
        TContext
      > => {

      const mutationOptions = getStartRunMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get run summary
 */
export const getRun = (
    runId: string,
 signal?: AbortSignal
) => {
      
      
      return client<Run>(
      {url: `/api/v1/runs/${runId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetRunQueryKey = (runId?: string,) => {
    return [
    `/api/v1/runs/${runId}`
    ] as const;
    }

    
export const getGetRunQueryOptions = <TData = Awaited<ReturnType<typeof getRun>>, TError = NotFoundResponse>(runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRun>>> = ({ signal }) => getRun(runId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRunQueryResult = NonNullable<Awaited<ReturnType<typeof getRun>>>
export type GetRunQueryError = NotFoundResponse


export function useGetRun<TData = Awaited<ReturnType<typeof getRun>>, TError = NotFoundResponse>(
 runId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRun>>,
          TError,
          Awaited<ReturnType<typeof getRun>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRun<TData = Awaited<ReturnType<typeof getRun>>, TError = NotFoundResponse>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRun>>,
          TError,
          Awaited<ReturnType<typeof getRun>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRun<TData = Awaited<ReturnType<typeof getRun>>, TError = NotFoundResponse>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get run summary
 */

export function useGetRun<TData = Awaited<ReturnType<typeof getRun>>, TError = NotFoundResponse>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRun>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRunQueryOptions(runId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Cancel a run
 */
export const cancelRun = (
    runId: string,
 signal?: AbortSignal
) => {
      
      
      return client<RunRef>(
      {url: `/api/v1/runs/${runId}/cancel`, method: 'POST', signal
    },
      );
    }
  


export const getCancelRunMutationOptions = <TError = NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelRun>>, TError,{runId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof cancelRun>>, TError,{runId: string}, TContext> => {

const mutationKey = ['cancelRun'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelRun>>, {runId: string}> = (props) => {
          const {runId} = props ?? {};

          return  cancelRun(runId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelRunMutationResult = NonNullable<Awaited<ReturnType<typeof cancelRun>>>
    
    export type CancelRunMutationError = NotFoundResponse

    /**
 * @summary Cancel a run
 */
export const useCancelRun = <TError = NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelRun>>, TError,{runId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelRun>>,
        TError,
        {runId: string},
        TContext
      > => {

      const mutationOptions = getCancelRunMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get the immutable workflow snapshot used by this run
 */
export const getRunDefinition = (
    runId: string,
 signal?: AbortSignal
) => {
      
      
      return client<Workflow>(
      {url: `/api/v1/runs/${runId}/definition`, method: 'GET', signal
    },
      );
    }
  



export const getGetRunDefinitionQueryKey = (runId?: string,) => {
    return [
    `/api/v1/runs/${runId}/definition`
    ] as const;
    }

    
export const getGetRunDefinitionQueryOptions = <TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = NotFoundResponse>(runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRunDefinitionQueryKey(runId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunDefinition>>> = ({ signal }) => getRunDefinition(runId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(runId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRunDefinitionQueryResult = NonNullable<Awaited<ReturnType<typeof getRunDefinition>>>
export type GetRunDefinitionQueryError = NotFoundResponse


export function useGetRunDefinition<TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = NotFoundResponse>(
 runId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRunDefinition>>,
          TError,
          Awaited<ReturnType<typeof getRunDefinition>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRunDefinition<TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = NotFoundResponse>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRunDefinition>>,
          TError,
          Awaited<ReturnType<typeof getRunDefinition>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRunDefinition<TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = NotFoundResponse>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get the immutable workflow snapshot used by this run
 */

export function useGetRunDefinition<TData = Awaited<ReturnType<typeof getRunDefinition>>, TError = NotFoundResponse>(
 runId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRunDefinition>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRunDefinitionQueryOptions(runId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List stored workflows (paginated)
 */
export const listWorkflows = (
    params?: ListWorkflowsParams,
 signal?: AbortSignal
) => {
      
      
      return client<WorkflowList>(
      {url: `/api/v1/workflows`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListWorkflowsQueryKey = (params?: ListWorkflowsParams,) => {
    return [
    `/api/v1/workflows`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListWorkflowsQueryOptions = <TData = Awaited<ReturnType<typeof listWorkflows>>, TError = unknown>(params?: ListWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWorkflowsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWorkflows>>> = ({ signal }) => listWorkflows(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListWorkflowsQueryResult = NonNullable<Awaited<ReturnType<typeof listWorkflows>>>
export type ListWorkflowsQueryError = unknown


export function useListWorkflows<TData = Awaited<ReturnType<typeof listWorkflows>>, TError = unknown>(
 params: undefined |  ListWorkflowsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflows>>,
          TError,
          Awaited<ReturnType<typeof listWorkflows>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflows<TData = Awaited<ReturnType<typeof listWorkflows>>, TError = unknown>(
 params?: ListWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflows>>,
          TError,
          Awaited<ReturnType<typeof listWorkflows>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflows<TData = Awaited<ReturnType<typeof listWorkflows>>, TError = unknown>(
 params?: ListWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List stored workflows (paginated)
 */

export function useListWorkflows<TData = Awaited<ReturnType<typeof listWorkflows>>, TError = unknown>(
 params?: ListWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflows>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListWorkflowsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Persist a workflow for editor storage (no versioning)
 */
export const persistWorkflow = (
    workflow: Workflow,
 signal?: AbortSignal
) => {
      
      
      return client<WorkflowRef>(
      {url: `/api/v1/workflows`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: workflow, signal
    },
      );
    }
  


export const getPersistWorkflowMutationOptions = <TError = BadRequestResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof persistWorkflow>>, TError,{data: Workflow}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof persistWorkflow>>, TError,{data: Workflow}, TContext> => {

const mutationKey = ['persistWorkflow'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof persistWorkflow>>, {data: Workflow}> = (props) => {
          const {data} = props ?? {};

          return  persistWorkflow(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PersistWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof persistWorkflow>>>
    export type PersistWorkflowMutationBody = Workflow
    export type PersistWorkflowMutationError = BadRequestResponse | ConflictResponse

    /**
 * @summary Persist a workflow for editor storage (no versioning)
 */
export const usePersistWorkflow = <TError = BadRequestResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof persistWorkflow>>, TError,{data: Workflow}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof persistWorkflow>>,
        TError,
        {data: Workflow},
        TContext
      > => {

      const mutationOptions = getPersistWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Read stored workflow (latest)
 */
export const getWorkflow = (
    workflowId: string,
 signal?: AbortSignal
) => {
      
      
      return client<Workflow>(
      {url: `/api/v1/workflows/${workflowId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetWorkflowQueryKey = (workflowId?: string,) => {
    return [
    `/api/v1/workflows/${workflowId}`
    ] as const;
    }

    
export const getGetWorkflowQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflow>>, TError = NotFoundResponse>(workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowQueryKey(workflowId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflow>>> = ({ signal }) => getWorkflow(workflowId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(workflowId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkflowQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflow>>>
export type GetWorkflowQueryError = NotFoundResponse


export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = NotFoundResponse>(
 workflowId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getWorkflow>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = NotFoundResponse>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflow>>,
          TError,
          Awaited<ReturnType<typeof getWorkflow>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = NotFoundResponse>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Read stored workflow (latest)
 */

export function useGetWorkflow<TData = Awaited<ReturnType<typeof getWorkflow>>, TError = NotFoundResponse>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkflowQueryOptions(workflowId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Marks the workflow record as deleted so it is hidden from listings and future reads.
 * @summary Soft delete workflow
 */
export const deleteWorkflow = (
    workflowId: string,
 ) => {
      
      
      return client<void>(
      {url: `/api/v1/workflows/${workflowId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteWorkflowMutationOptions = <TError = ForbiddenResponse | NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflow>>, TError,{workflowId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflow>>, TError,{workflowId: string}, TContext> => {

const mutationKey = ['deleteWorkflow'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWorkflow>>, {workflowId: string}> = (props) => {
          const {workflowId} = props ?? {};

          return  deleteWorkflow(workflowId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWorkflow>>>
    
    export type DeleteWorkflowMutationError = ForbiddenResponse | NotFoundResponse

    /**
 * @summary Soft delete workflow
 */
export const useDeleteWorkflow = <TError = ForbiddenResponse | NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflow>>, TError,{workflowId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteWorkflow>>,
        TError,
        {workflowId: string},
        TContext
      > => {

      const mutationOptions = getDeleteWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get workflow canvas preview
 */
export const getWorkflowPreview = (
    workflowId: string,
 signal?: AbortSignal
) => {
      
      
      return client<WorkflowPreview>(
      {url: `/api/v1/workflows/${workflowId}/preview`, method: 'GET', signal
    },
      );
    }
  



export const getGetWorkflowPreviewQueryKey = (workflowId?: string,) => {
    return [
    `/api/v1/workflows/${workflowId}/preview`
    ] as const;
    }

    
export const getGetWorkflowPreviewQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowPreview>>, TError = NotFoundResponse>(workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPreview>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowPreviewQueryKey(workflowId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowPreview>>> = ({ signal }) => getWorkflowPreview(workflowId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(workflowId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPreview>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkflowPreviewQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowPreview>>>
export type GetWorkflowPreviewQueryError = NotFoundResponse


export function useGetWorkflowPreview<TData = Awaited<ReturnType<typeof getWorkflowPreview>>, TError = NotFoundResponse>(
 workflowId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPreview>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPreview>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPreview>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflowPreview<TData = Awaited<ReturnType<typeof getWorkflowPreview>>, TError = NotFoundResponse>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPreview>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPreview>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPreview>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflowPreview<TData = Awaited<ReturnType<typeof getWorkflowPreview>>, TError = NotFoundResponse>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPreview>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get workflow canvas preview
 */

export function useGetWorkflowPreview<TData = Awaited<ReturnType<typeof getWorkflowPreview>>, TError = NotFoundResponse>(
 workflowId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPreview>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkflowPreviewQueryOptions(workflowId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Set or clear workflow canvas preview
 */
export const setWorkflowPreview = (
    workflowId: string,
    workflowPreview: WorkflowPreview,
 ) => {
      
      
      return client<WorkflowPreview>(
      {url: `/api/v1/workflows/${workflowId}/preview`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: workflowPreview
    },
      );
    }
  


export const getSetWorkflowPreviewMutationOptions = <TError = NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setWorkflowPreview>>, TError,{workflowId: string;data: WorkflowPreview}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof setWorkflowPreview>>, TError,{workflowId: string;data: WorkflowPreview}, TContext> => {

const mutationKey = ['setWorkflowPreview'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setWorkflowPreview>>, {workflowId: string;data: WorkflowPreview}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  setWorkflowPreview(workflowId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetWorkflowPreviewMutationResult = NonNullable<Awaited<ReturnType<typeof setWorkflowPreview>>>
    export type SetWorkflowPreviewMutationBody = WorkflowPreview
    export type SetWorkflowPreviewMutationError = NotFoundResponse

    /**
 * @summary Set or clear workflow canvas preview
 */
export const useSetWorkflowPreview = <TError = NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setWorkflowPreview>>, TError,{workflowId: string;data: WorkflowPreview}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setWorkflowPreview>>,
        TError,
        {workflowId: string;data: WorkflowPreview},
        TContext
      > => {

      const mutationOptions = getSetWorkflowPreviewMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List published workflow packages
 */
export const listWorkflowPackages = (
    params?: ListWorkflowPackagesParams,
 signal?: AbortSignal
) => {
      
      
      return client<WorkflowPackageList>(
      {url: `/api/v1/workflow-packages`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListWorkflowPackagesQueryKey = (params?: ListWorkflowPackagesParams,) => {
    return [
    `/api/v1/workflow-packages`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListWorkflowPackagesQueryOptions = <TData = Awaited<ReturnType<typeof listWorkflowPackages>>, TError = unknown>(params?: ListWorkflowPackagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackages>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWorkflowPackagesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWorkflowPackages>>> = ({ signal }) => listWorkflowPackages(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListWorkflowPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof listWorkflowPackages>>>
export type ListWorkflowPackagesQueryError = unknown


export function useListWorkflowPackages<TData = Awaited<ReturnType<typeof listWorkflowPackages>>, TError = unknown>(
 params: undefined |  ListWorkflowPackagesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflowPackages>>,
          TError,
          Awaited<ReturnType<typeof listWorkflowPackages>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflowPackages<TData = Awaited<ReturnType<typeof listWorkflowPackages>>, TError = unknown>(
 params?: ListWorkflowPackagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflowPackages>>,
          TError,
          Awaited<ReturnType<typeof listWorkflowPackages>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflowPackages<TData = Awaited<ReturnType<typeof listWorkflowPackages>>, TError = unknown>(
 params?: ListWorkflowPackagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackages>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List published workflow packages
 */

export function useListWorkflowPackages<TData = Awaited<ReturnType<typeof listWorkflowPackages>>, TError = unknown>(
 params?: ListWorkflowPackagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackages>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListWorkflowPackagesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a workflow package detail
 */
export const getWorkflowPackage = (
    packageId: string,
 signal?: AbortSignal
) => {
      
      
      return client<WorkflowPackageDetail>(
      {url: `/api/v1/workflow-packages/${packageId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetWorkflowPackageQueryKey = (packageId?: string,) => {
    return [
    `/api/v1/workflow-packages/${packageId}`
    ] as const;
    }

    
export const getGetWorkflowPackageQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowPackage>>, TError = NotFoundResponse>(packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPackage>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowPackageQueryKey(packageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowPackage>>> = ({ signal }) => getWorkflowPackage(packageId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(packageId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPackage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkflowPackageQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowPackage>>>
export type GetWorkflowPackageQueryError = NotFoundResponse


export function useGetWorkflowPackage<TData = Awaited<ReturnType<typeof getWorkflowPackage>>, TError = NotFoundResponse>(
 packageId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPackage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPackage>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPackage>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflowPackage<TData = Awaited<ReturnType<typeof getWorkflowPackage>>, TError = NotFoundResponse>(
 packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPackage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPackage>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPackage>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflowPackage<TData = Awaited<ReturnType<typeof getWorkflowPackage>>, TError = NotFoundResponse>(
 packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPackage>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a workflow package detail
 */

export function useGetWorkflowPackage<TData = Awaited<ReturnType<typeof getWorkflowPackage>>, TError = NotFoundResponse>(
 packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPackage>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkflowPackageQueryOptions(packageId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete a workflow package
 */
export const deleteWorkflowPackage = (
    packageId: string,
 ) => {
      
      
      return client<void>(
      {url: `/api/v1/workflow-packages/${packageId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteWorkflowPackageMutationOptions = <TError = NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflowPackage>>, TError,{packageId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflowPackage>>, TError,{packageId: string}, TContext> => {

const mutationKey = ['deleteWorkflowPackage'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWorkflowPackage>>, {packageId: string}> = (props) => {
          const {packageId} = props ?? {};

          return  deleteWorkflowPackage(packageId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteWorkflowPackageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWorkflowPackage>>>
    
    export type DeleteWorkflowPackageMutationError = NotFoundResponse

    /**
 * @summary Delete a workflow package
 */
export const useDeleteWorkflowPackage = <TError = NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflowPackage>>, TError,{packageId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteWorkflowPackage>>,
        TError,
        {packageId: string},
        TContext
      > => {

      const mutationOptions = getDeleteWorkflowPackageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List versions for a workflow package
 */
export const listWorkflowPackageVersions = (
    packageId: string,
 signal?: AbortSignal
) => {
      
      
      return client<WorkflowPackageVersionList>(
      {url: `/api/v1/workflow-packages/${packageId}/versions`, method: 'GET', signal
    },
      );
    }
  



export const getListWorkflowPackageVersionsQueryKey = (packageId?: string,) => {
    return [
    `/api/v1/workflow-packages/${packageId}/versions`
    ] as const;
    }

    
export const getListWorkflowPackageVersionsQueryOptions = <TData = Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError = NotFoundResponse>(packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWorkflowPackageVersionsQueryKey(packageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWorkflowPackageVersions>>> = ({ signal }) => listWorkflowPackageVersions(packageId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(packageId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListWorkflowPackageVersionsQueryResult = NonNullable<Awaited<ReturnType<typeof listWorkflowPackageVersions>>>
export type ListWorkflowPackageVersionsQueryError = NotFoundResponse


export function useListWorkflowPackageVersions<TData = Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError = NotFoundResponse>(
 packageId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflowPackageVersions>>,
          TError,
          Awaited<ReturnType<typeof listWorkflowPackageVersions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflowPackageVersions<TData = Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError = NotFoundResponse>(
 packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflowPackageVersions>>,
          TError,
          Awaited<ReturnType<typeof listWorkflowPackageVersions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkflowPackageVersions<TData = Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError = NotFoundResponse>(
 packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List versions for a workflow package
 */

export function useListWorkflowPackageVersions<TData = Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError = NotFoundResponse>(
 packageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowPackageVersions>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListWorkflowPackageVersionsQueryOptions(packageId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Clone a workflow package version into the caller's workspace
 */
export const cloneWorkflowPackage = (
    packageId: string,
    workflowPackageCloneRequest?: WorkflowPackageCloneRequest,
 signal?: AbortSignal
) => {
      
      
      return client<WorkflowRef>(
      {url: `/api/v1/workflow-packages/${packageId}/clone`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: workflowPackageCloneRequest, signal
    },
      );
    }
  


export const getCloneWorkflowPackageMutationOptions = <TError = NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cloneWorkflowPackage>>, TError,{packageId: string;data: WorkflowPackageCloneRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof cloneWorkflowPackage>>, TError,{packageId: string;data: WorkflowPackageCloneRequest}, TContext> => {

const mutationKey = ['cloneWorkflowPackage'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cloneWorkflowPackage>>, {packageId: string;data: WorkflowPackageCloneRequest}> = (props) => {
          const {packageId,data} = props ?? {};

          return  cloneWorkflowPackage(packageId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CloneWorkflowPackageMutationResult = NonNullable<Awaited<ReturnType<typeof cloneWorkflowPackage>>>
    export type CloneWorkflowPackageMutationBody = WorkflowPackageCloneRequest
    export type CloneWorkflowPackageMutationError = NotFoundResponse

    /**
 * @summary Clone a workflow package version into the caller's workspace
 */
export const useCloneWorkflowPackage = <TError = NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cloneWorkflowPackage>>, TError,{packageId: string;data: WorkflowPackageCloneRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cloneWorkflowPackage>>,
        TError,
        {packageId: string;data: WorkflowPackageCloneRequest},
        TContext
      > => {

      const mutationOptions = getCloneWorkflowPackageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Publish a workflow draft to the Store
 */
export const publishWorkflow = (
    workflowId: string,
    workflowPublishRequest: WorkflowPublishRequest,
 signal?: AbortSignal
) => {
      
      
      return client<WorkflowPublishResponse>(
      {url: `/api/v1/workflows/${workflowId}/publish`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: workflowPublishRequest, signal
    },
      );
    }
  


export const getPublishWorkflowMutationOptions = <TError = BadRequestResponse | ForbiddenResponse | NotFoundResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishWorkflow>>, TError,{workflowId: string;data: WorkflowPublishRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof publishWorkflow>>, TError,{workflowId: string;data: WorkflowPublishRequest}, TContext> => {

const mutationKey = ['publishWorkflow'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof publishWorkflow>>, {workflowId: string;data: WorkflowPublishRequest}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  publishWorkflow(workflowId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PublishWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof publishWorkflow>>>
    export type PublishWorkflowMutationBody = WorkflowPublishRequest
    export type PublishWorkflowMutationError = BadRequestResponse | ForbiddenResponse | NotFoundResponse | ConflictResponse

    /**
 * @summary Publish a workflow draft to the Store
 */
export const usePublishWorkflow = <TError = BadRequestResponse | ForbiddenResponse | NotFoundResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishWorkflow>>, TError,{workflowId: string;data: WorkflowPublishRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof publishWorkflow>>,
        TError,
        {workflowId: string;data: WorkflowPublishRequest},
        TContext
      > => {

      const mutationOptions = getPublishWorkflowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List available packages
 */
export const listPackages = (
    
 signal?: AbortSignal
) => {
      
      
      return client<PackageList>(
      {url: `/api/v1/packages`, method: 'GET', signal
    },
      );
    }
  



export const getListPackagesQueryKey = () => {
    return [
    `/api/v1/packages`
    ] as const;
    }

    
export const getListPackagesQueryOptions = <TData = Awaited<ReturnType<typeof listPackages>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPackagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPackages>>> = ({ signal }) => listPackages(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof listPackages>>>
export type ListPackagesQueryError = unknown


export function useListPackages<TData = Awaited<ReturnType<typeof listPackages>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPackages>>,
          TError,
          Awaited<ReturnType<typeof listPackages>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPackages<TData = Awaited<ReturnType<typeof listPackages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPackages>>,
          TError,
          Awaited<ReturnType<typeof listPackages>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPackages<TData = Awaited<ReturnType<typeof listPackages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List available packages
 */

export function useListPackages<TData = Awaited<ReturnType<typeof listPackages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPackages>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPackagesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get package detail
 */
export const getPackage = (
    packageName: string,
    params?: GetPackageParams,
 signal?: AbortSignal
) => {
      
      
      return client<PackageDetail>(
      {url: `/api/v1/packages/${packageName}`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetPackageQueryKey = (packageName?: string,
    params?: GetPackageParams,) => {
    return [
    `/api/v1/packages/${packageName}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetPackageQueryOptions = <TData = Awaited<ReturnType<typeof getPackage>>, TError = NotFoundResponse>(packageName: string,
    params?: GetPackageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPackageQueryKey(packageName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPackage>>> = ({ signal }) => getPackage(packageName,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(packageName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPackageQueryResult = NonNullable<Awaited<ReturnType<typeof getPackage>>>
export type GetPackageQueryError = NotFoundResponse


export function useGetPackage<TData = Awaited<ReturnType<typeof getPackage>>, TError = NotFoundResponse>(
 packageName: string,
    params: undefined |  GetPackageParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPackage>>,
          TError,
          Awaited<ReturnType<typeof getPackage>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPackage<TData = Awaited<ReturnType<typeof getPackage>>, TError = NotFoundResponse>(
 packageName: string,
    params?: GetPackageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPackage>>,
          TError,
          Awaited<ReturnType<typeof getPackage>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPackage<TData = Awaited<ReturnType<typeof getPackage>>, TError = NotFoundResponse>(
 packageName: string,
    params?: GetPackageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get package detail
 */

export function useGetPackage<TData = Awaited<ReturnType<typeof getPackage>>, TError = NotFoundResponse>(
 packageName: string,
    params?: GetPackageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPackage>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPackageQueryOptions(packageName,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Search catalog nodes (system + worker capabilities)
 */
export const searchCatalogNodes = (
    params: SearchCatalogNodesParams,
 signal?: AbortSignal
) => {
      
      
      return client<CatalogNodeSearchResponse>(
      {url: `/api/v1/catalog/nodes/search`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getSearchCatalogNodesQueryKey = (params?: SearchCatalogNodesParams,) => {
    return [
    `/api/v1/catalog/nodes/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSearchCatalogNodesQueryOptions = <TData = Awaited<ReturnType<typeof searchCatalogNodes>>, TError = BadRequestResponse>(params: SearchCatalogNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchCatalogNodes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchCatalogNodesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchCatalogNodes>>> = ({ signal }) => searchCatalogNodes(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchCatalogNodes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SearchCatalogNodesQueryResult = NonNullable<Awaited<ReturnType<typeof searchCatalogNodes>>>
export type SearchCatalogNodesQueryError = BadRequestResponse


export function useSearchCatalogNodes<TData = Awaited<ReturnType<typeof searchCatalogNodes>>, TError = BadRequestResponse>(
 params: SearchCatalogNodesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchCatalogNodes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchCatalogNodes>>,
          TError,
          Awaited<ReturnType<typeof searchCatalogNodes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchCatalogNodes<TData = Awaited<ReturnType<typeof searchCatalogNodes>>, TError = BadRequestResponse>(
 params: SearchCatalogNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchCatalogNodes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchCatalogNodes>>,
          TError,
          Awaited<ReturnType<typeof searchCatalogNodes>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchCatalogNodes<TData = Awaited<ReturnType<typeof searchCatalogNodes>>, TError = BadRequestResponse>(
 params: SearchCatalogNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchCatalogNodes>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Search catalog nodes (system + worker capabilities)
 */

export function useSearchCatalogNodes<TData = Awaited<ReturnType<typeof searchCatalogNodes>>, TError = BadRequestResponse>(
 params: SearchCatalogNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchCatalogNodes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSearchCatalogNodesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List workers (scheduler view)
 */
export const listWorkers = (
    params?: ListWorkersParams,
 signal?: AbortSignal
) => {
      
      
      return client<ListWorkers200>(
      {url: `/api/v1/workers`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListWorkersQueryKey = (params?: ListWorkersParams,) => {
    return [
    `/api/v1/workers`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListWorkersQueryOptions = <TData = Awaited<ReturnType<typeof listWorkers>>, TError = unknown>(params?: ListWorkersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWorkersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWorkers>>> = ({ signal }) => listWorkers(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListWorkersQueryResult = NonNullable<Awaited<ReturnType<typeof listWorkers>>>
export type ListWorkersQueryError = unknown


export function useListWorkers<TData = Awaited<ReturnType<typeof listWorkers>>, TError = unknown>(
 params: undefined |  ListWorkersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkers>>,
          TError,
          Awaited<ReturnType<typeof listWorkers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkers<TData = Awaited<ReturnType<typeof listWorkers>>, TError = unknown>(
 params?: ListWorkersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkers>>,
          TError,
          Awaited<ReturnType<typeof listWorkers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListWorkers<TData = Awaited<ReturnType<typeof listWorkers>>, TError = unknown>(
 params?: ListWorkersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List workers (scheduler view)
 */

export function useListWorkers<TData = Awaited<ReturnType<typeof listWorkers>>, TError = unknown>(
 params?: ListWorkersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListWorkersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get worker snapshot
 */
export const getWorker = (
    workerId: string,
 signal?: AbortSignal
) => {
      
      
      return client<Worker>(
      {url: `/api/v1/workers/${workerId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetWorkerQueryKey = (workerId?: string,) => {
    return [
    `/api/v1/workers/${workerId}`
    ] as const;
    }

    
export const getGetWorkerQueryOptions = <TData = Awaited<ReturnType<typeof getWorker>>, TError = NotFoundResponse>(workerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkerQueryKey(workerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorker>>> = ({ signal }) => getWorker(workerId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(workerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkerQueryResult = NonNullable<Awaited<ReturnType<typeof getWorker>>>
export type GetWorkerQueryError = NotFoundResponse


export function useGetWorker<TData = Awaited<ReturnType<typeof getWorker>>, TError = NotFoundResponse>(
 workerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorker>>,
          TError,
          Awaited<ReturnType<typeof getWorker>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorker<TData = Awaited<ReturnType<typeof getWorker>>, TError = NotFoundResponse>(
 workerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorker>>,
          TError,
          Awaited<ReturnType<typeof getWorker>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorker<TData = Awaited<ReturnType<typeof getWorker>>, TError = NotFoundResponse>(
 workerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get worker snapshot
 */

export function useGetWorker<TData = Awaited<ReturnType<typeof getWorker>>, TError = NotFoundResponse>(
 workerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorker>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkerQueryOptions(workerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Enqueue admin command (drain/rebind/pkg.install/pkg.uninstall)
 */
export const sendWorkerCommand = (
    workerId: string,
    workerCommand: WorkerCommand,
 signal?: AbortSignal
) => {
      
      
      return client<CommandRef>(
      {url: `/api/v1/workers/${workerId}/commands`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: workerCommand, signal
    },
      );
    }
  


export const getSendWorkerCommandMutationOptions = <TError = BadRequestResponse | NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendWorkerCommand>>, TError,{workerId: string;data: WorkerCommand}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendWorkerCommand>>, TError,{workerId: string;data: WorkerCommand}, TContext> => {

const mutationKey = ['sendWorkerCommand'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendWorkerCommand>>, {workerId: string;data: WorkerCommand}> = (props) => {
          const {workerId,data} = props ?? {};

          return  sendWorkerCommand(workerId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendWorkerCommandMutationResult = NonNullable<Awaited<ReturnType<typeof sendWorkerCommand>>>
    export type SendWorkerCommandMutationBody = WorkerCommand
    export type SendWorkerCommandMutationError = BadRequestResponse | NotFoundResponse

    /**
 * @summary Enqueue admin command (drain/rebind/pkg.install/pkg.uninstall)
 */
export const useSendWorkerCommand = <TError = BadRequestResponse | NotFoundResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendWorkerCommand>>, TError,{workerId: string;data: WorkerCommand}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendWorkerCommand>>,
        TError,
        {workerId: string;data: WorkerCommand},
        TContext
      > => {

      const mutationOptions = getSendWorkerCommandMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Global Server-Sent Events stream (firehose; no query parameters)
 */
export const sseGlobalEvents = (
    params: SseGlobalEventsParams,
 signal?: AbortSignal
) => {
      
      
      return client<string>(
      {url: `/api/v1/events`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getSseGlobalEventsQueryKey = (params?: SseGlobalEventsParams,) => {
    return [
    `/api/v1/events`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSseGlobalEventsQueryOptions = <TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = unknown>(params: SseGlobalEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSseGlobalEventsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sseGlobalEvents>>> = ({ signal }) => sseGlobalEvents(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SseGlobalEventsQueryResult = NonNullable<Awaited<ReturnType<typeof sseGlobalEvents>>>
export type SseGlobalEventsQueryError = unknown


export function useSseGlobalEvents<TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = unknown>(
 params: SseGlobalEventsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sseGlobalEvents>>,
          TError,
          Awaited<ReturnType<typeof sseGlobalEvents>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSseGlobalEvents<TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = unknown>(
 params: SseGlobalEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sseGlobalEvents>>,
          TError,
          Awaited<ReturnType<typeof sseGlobalEvents>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSseGlobalEvents<TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = unknown>(
 params: SseGlobalEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Global Server-Sent Events stream (firehose; no query parameters)
 */

export function useSseGlobalEvents<TData = Awaited<ReturnType<typeof sseGlobalEvents>>, TError = unknown>(
 params: SseGlobalEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sseGlobalEvents>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSseGlobalEventsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List users and their roles
 */
export const listUsers = (
    
 signal?: AbortSignal
) => {
      
      
      return client<UserList>(
      {url: `/api/v1/users`, method: 'GET', signal
    },
      );
    }
  



export const getListUsersQueryKey = () => {
    return [
    `/api/v1/users`
    ] as const;
    }

    
export const getListUsersQueryOptions = <TData = Awaited<ReturnType<typeof listUsers>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsers>>> = ({ signal }) => listUsers(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListUsersQueryResult = NonNullable<Awaited<ReturnType<typeof listUsers>>>
export type ListUsersQueryError = unknown


export function useListUsers<TData = Awaited<ReturnType<typeof listUsers>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListUsers<TData = Awaited<ReturnType<typeof listUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListUsers<TData = Awaited<ReturnType<typeof listUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List users and their roles
 */

export function useListUsers<TData = Awaited<ReturnType<typeof listUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new user
 */
export const createUser = (
    createUserRequest: CreateUserRequest,
 signal?: AbortSignal
) => {
      
      
      return client<UserSummary>(
      {url: `/api/v1/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createUserRequest, signal
    },
      );
    }
  


export const getCreateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserRequest}, TContext> => {

const mutationKey = ['createUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: CreateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = CreateUserRequest
    export type CreateUserMutationError = unknown

    /**
 * @summary Create a new user
 */
export const useCreateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: CreateUserRequest},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Reset user password
 */
export const resetUserPassword = (
    userId: string,
    resetUserPasswordRequest: ResetUserPasswordRequest,
 signal?: AbortSignal
) => {
      
      
      return client<void>(
      {url: `/api/v1/users/${userId}/password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resetUserPasswordRequest, signal
    },
      );
    }
  


export const getResetUserPasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetUserPassword>>, TError,{userId: string;data: ResetUserPasswordRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof resetUserPassword>>, TError,{userId: string;data: ResetUserPasswordRequest}, TContext> => {

const mutationKey = ['resetUserPassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetUserPassword>>, {userId: string;data: ResetUserPasswordRequest}> = (props) => {
          const {userId,data} = props ?? {};

          return  resetUserPassword(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetUserPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof resetUserPassword>>>
    export type ResetUserPasswordMutationBody = ResetUserPasswordRequest
    export type ResetUserPasswordMutationError = unknown

    /**
 * @summary Reset user password
 */
export const useResetUserPassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetUserPassword>>, TError,{userId: string;data: ResetUserPasswordRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetUserPassword>>,
        TError,
        {userId: string;data: ResetUserPasswordRequest},
        TContext
      > => {

      const mutationOptions = getResetUserPasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Assign role to user
 */
export const addUserRole = (
    userId: string,
    userRoleRequest: UserRoleRequest,
 signal?: AbortSignal
) => {
      
      
      return client<void>(
      {url: `/api/v1/users/${userId}/roles`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userRoleRequest, signal
    },
      );
    }
  


export const getAddUserRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addUserRole>>, TError,{userId: string;data: UserRoleRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addUserRole>>, TError,{userId: string;data: UserRoleRequest}, TContext> => {

const mutationKey = ['addUserRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addUserRole>>, {userId: string;data: UserRoleRequest}> = (props) => {
          const {userId,data} = props ?? {};

          return  addUserRole(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddUserRoleMutationResult = NonNullable<Awaited<ReturnType<typeof addUserRole>>>
    export type AddUserRoleMutationBody = UserRoleRequest
    export type AddUserRoleMutationError = unknown

    /**
 * @summary Assign role to user
 */
export const useAddUserRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addUserRole>>, TError,{userId: string;data: UserRoleRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addUserRole>>,
        TError,
        {userId: string;data: UserRoleRequest},
        TContext
      > => {

      const mutationOptions = getAddUserRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Remove role from user
 */
export const removeUserRole = (
    userId: string,
    role: string,
 ) => {
      
      
      return client<void>(
      {url: `/api/v1/users/${userId}/roles/${role}`, method: 'DELETE'
    },
      );
    }
  


export const getRemoveUserRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUserRole>>, TError,{userId: string;role: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof removeUserRole>>, TError,{userId: string;role: string}, TContext> => {

const mutationKey = ['removeUserRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUserRole>>, {userId: string;role: string}> = (props) => {
          const {userId,role} = props ?? {};

          return  removeUserRole(userId,role,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveUserRoleMutationResult = NonNullable<Awaited<ReturnType<typeof removeUserRole>>>
    
    export type RemoveUserRoleMutationError = unknown

    /**
 * @summary Remove role from user
 */
export const useRemoveUserRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUserRole>>, TError,{userId: string;role: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeUserRole>>,
        TError,
        {userId: string;role: string},
        TContext
      > => {

      const mutationOptions = getRemoveUserRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Toggle user active state
 */
export const updateUserStatus = (
    userId: string,
    updateUserStatusRequest: UpdateUserStatusRequest,
 ) => {
      
      
      return client<void>(
      {url: `/api/v1/users/${userId}/status`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateUserStatusRequest
    },
      );
    }
  


export const getUpdateUserStatusMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserStatus>>, TError,{userId: string;data: UpdateUserStatusRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUserStatus>>, TError,{userId: string;data: UpdateUserStatusRequest}, TContext> => {

const mutationKey = ['updateUserStatus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserStatus>>, {userId: string;data: UpdateUserStatusRequest}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUserStatus(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserStatus>>>
    export type UpdateUserStatusMutationBody = UpdateUserStatusRequest
    export type UpdateUserStatusMutationError = unknown

    /**
 * @summary Toggle user active state
 */
export const useUpdateUserStatus = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserStatus>>, TError,{userId: string;data: UpdateUserStatusRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUserStatus>>,
        TError,
        {userId: string;data: UpdateUserStatusRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List audit events
 */
export const listAuditEvents = (
    params?: ListAuditEventsParams,
 signal?: AbortSignal
) => {
      
      
      return client<AuditEventList>(
      {url: `/api/v1/audit-events`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListAuditEventsQueryKey = (params?: ListAuditEventsParams,) => {
    return [
    `/api/v1/audit-events`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAuditEventsQueryOptions = <TData = Awaited<ReturnType<typeof listAuditEvents>>, TError = unknown>(params?: ListAuditEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAuditEvents>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAuditEventsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAuditEvents>>> = ({ signal }) => listAuditEvents(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAuditEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAuditEventsQueryResult = NonNullable<Awaited<ReturnType<typeof listAuditEvents>>>
export type ListAuditEventsQueryError = unknown


export function useListAuditEvents<TData = Awaited<ReturnType<typeof listAuditEvents>>, TError = unknown>(
 params: undefined |  ListAuditEventsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAuditEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAuditEvents>>,
          TError,
          Awaited<ReturnType<typeof listAuditEvents>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAuditEvents<TData = Awaited<ReturnType<typeof listAuditEvents>>, TError = unknown>(
 params?: ListAuditEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAuditEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAuditEvents>>,
          TError,
          Awaited<ReturnType<typeof listAuditEvents>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAuditEvents<TData = Awaited<ReturnType<typeof listAuditEvents>>, TError = unknown>(
 params?: ListAuditEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAuditEvents>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List audit events
 */

export function useListAuditEvents<TData = Awaited<ReturnType<typeof listAuditEvents>>, TError = unknown>(
 params?: ListAuditEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAuditEvents>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAuditEventsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
