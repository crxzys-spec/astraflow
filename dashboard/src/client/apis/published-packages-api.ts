/* tslint:disable */
/* eslint-disable */
/**
 * Scheduler Public API (v1)
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { PackageDetail } from '../models';
// @ts-ignore
import type { PackageList } from '../models';
// @ts-ignore
import type { PublishedPackageGcRequest } from '../models';
// @ts-ignore
import type { PublishedPackageGcResult } from '../models';
// @ts-ignore
import type { PublishedPackageRegistry } from '../models';
// @ts-ignore
import type { PublishedPackageReserveRequest } from '../models';
// @ts-ignore
import type { PublishedPackageStatusRequest } from '../models';
// @ts-ignore
import type { PublishedPackageTagRequest } from '../models';
// @ts-ignore
import type { PublishedPackageTransferRequest } from '../models';
// @ts-ignore
import type { PublishedPackageVisibilityRequest } from '../models';
/**
 * PublishedPackagesApi - axios parameter creator
 */
export const PublishedPackagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete published package dist-tag
         * @param {string} packageName 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublishedPackageTag: async (packageName: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('deletePublishedPackageTag', 'packageName', packageName)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deletePublishedPackageTag', 'tag', tag)
            const localVarPath = `/api/v1/published-packages/{packageName}/tags/{tag}`
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download published package archive
         * @param {string} packageName 
         * @param {string} [version] Specific package version to retrieve. Defaults to the latest available version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPublishedPackage: async (packageName: string, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('downloadPublishedPackage', 'packageName', packageName)
            const localVarPath = `/api/v1/published-packages/{packageName}/archive`
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Garbage collect published package versions
         * @param {PublishedPackageGcRequest} publishedPackageGcRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcPublishedPackages: async (publishedPackageGcRequest: PublishedPackageGcRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publishedPackageGcRequest' is not null or undefined
            assertParamExists('gcPublishedPackages', 'publishedPackageGcRequest', publishedPackageGcRequest)
            const localVarPath = `/api/v1/published-packages/gc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishedPackageGcRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get published package detail
         * @param {string} packageName 
         * @param {string} [version] Specific package version to retrieve. Defaults to the latest available version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedPackage: async (packageName: string, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('getPublishedPackage', 'packageName', packageName)
            const localVarPath = `/api/v1/published-packages/{packageName}`
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get published package registry metadata
         * @param {string} packageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedPackageRegistry: async (packageName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('getPublishedPackageRegistry', 'packageName', packageName)
            const localVarPath = `/api/v1/published-packages/{packageName}/registry`
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List published packages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublishedPackages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/published-packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reserve a published package name
         * @param {string} packageName 
         * @param {PublishedPackageReserveRequest} [publishedPackageReserveRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservePublishedPackage: async (packageName: string, publishedPackageReserveRequest?: PublishedPackageReserveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('reservePublishedPackage', 'packageName', packageName)
            const localVarPath = `/api/v1/published-packages/{packageName}/reserve`
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishedPackageReserveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set published package dist-tag
         * @param {string} packageName 
         * @param {string} tag 
         * @param {PublishedPackageTagRequest} publishedPackageTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublishedPackageTag: async (packageName: string, tag: string, publishedPackageTagRequest: PublishedPackageTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('setPublishedPackageTag', 'packageName', packageName)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('setPublishedPackageTag', 'tag', tag)
            // verify required parameter 'publishedPackageTagRequest' is not null or undefined
            assertParamExists('setPublishedPackageTag', 'publishedPackageTagRequest', publishedPackageTagRequest)
            const localVarPath = `/api/v1/published-packages/{packageName}/tags/{tag}`
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishedPackageTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set published package version status
         * @param {string} packageName 
         * @param {string} version 
         * @param {PublishedPackageStatusRequest} publishedPackageStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublishedPackageVersionStatus: async (packageName: string, version: string, publishedPackageStatusRequest: PublishedPackageStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('setPublishedPackageVersionStatus', 'packageName', packageName)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('setPublishedPackageVersionStatus', 'version', version)
            // verify required parameter 'publishedPackageStatusRequest' is not null or undefined
            assertParamExists('setPublishedPackageVersionStatus', 'publishedPackageStatusRequest', publishedPackageStatusRequest)
            const localVarPath = `/api/v1/published-packages/{packageName}/versions/{version}`
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishedPackageStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer published package ownership
         * @param {string} packageName 
         * @param {PublishedPackageTransferRequest} publishedPackageTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferPublishedPackage: async (packageName: string, publishedPackageTransferRequest: PublishedPackageTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('transferPublishedPackage', 'packageName', packageName)
            // verify required parameter 'publishedPackageTransferRequest' is not null or undefined
            assertParamExists('transferPublishedPackage', 'publishedPackageTransferRequest', publishedPackageTransferRequest)
            const localVarPath = `/api/v1/published-packages/{packageName}/transfer`
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishedPackageTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update published package visibility
         * @param {string} packageName 
         * @param {PublishedPackageVisibilityRequest} publishedPackageVisibilityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublishedPackageVisibility: async (packageName: string, publishedPackageVisibilityRequest: PublishedPackageVisibilityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('updatePublishedPackageVisibility', 'packageName', packageName)
            // verify required parameter 'publishedPackageVisibilityRequest' is not null or undefined
            assertParamExists('updatePublishedPackageVisibility', 'publishedPackageVisibilityRequest', publishedPackageVisibilityRequest)
            const localVarPath = `/api/v1/published-packages/{packageName}/visibility`
                .replace(`{${"packageName"}}`, encodeURIComponent(String(packageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishedPackageVisibilityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a published package archive
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPublishedPackage: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadPublishedPackage', 'file', file)
            const localVarPath = `/api/v1/published-packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublishedPackagesApi - functional programming interface
 */
export const PublishedPackagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublishedPackagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete published package dist-tag
         * @param {string} packageName 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublishedPackageTag(packageName: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublishedPackageTag(packageName, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublishedPackagesApi.deletePublishedPackageTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download published package archive
         * @param {string} packageName 
         * @param {string} [version] Specific package version to retrieve. Defaults to the latest available version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadPublishedPackage(packageName: string, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadPublishedPackage(packageName, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublishedPackagesApi.downloadPublishedPackage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Garbage collect published package versions
         * @param {PublishedPackageGcRequest} publishedPackageGcRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gcPublishedPackages(publishedPackageGcRequest: PublishedPackageGcRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublishedPackageGcResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gcPublishedPackages(publishedPackageGcRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublishedPackagesApi.gcPublishedPackages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get published package detail
         * @param {string} packageName 
         * @param {string} [version] Specific package version to retrieve. Defaults to the latest available version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedPackage(packageName: string, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedPackage(packageName, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublishedPackagesApi.getPublishedPackage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get published package registry metadata
         * @param {string} packageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedPackageRegistry(packageName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublishedPackageRegistry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedPackageRegistry(packageName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublishedPackagesApi.getPublishedPackageRegistry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List published packages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPublishedPackages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPublishedPackages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublishedPackagesApi.listPublishedPackages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reserve a published package name
         * @param {string} packageName 
         * @param {PublishedPackageReserveRequest} [publishedPackageReserveRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservePublishedPackage(packageName: string, publishedPackageReserveRequest?: PublishedPackageReserveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublishedPackageRegistry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservePublishedPackage(packageName, publishedPackageReserveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublishedPackagesApi.reservePublishedPackage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set published package dist-tag
         * @param {string} packageName 
         * @param {string} tag 
         * @param {PublishedPackageTagRequest} publishedPackageTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPublishedPackageTag(packageName: string, tag: string, publishedPackageTagRequest: PublishedPackageTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPublishedPackageTag(packageName, tag, publishedPackageTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublishedPackagesApi.setPublishedPackageTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set published package version status
         * @param {string} packageName 
         * @param {string} version 
         * @param {PublishedPackageStatusRequest} publishedPackageStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPublishedPackageVersionStatus(packageName: string, version: string, publishedPackageStatusRequest: PublishedPackageStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPublishedPackageVersionStatus(packageName, version, publishedPackageStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublishedPackagesApi.setPublishedPackageVersionStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Transfer published package ownership
         * @param {string} packageName 
         * @param {PublishedPackageTransferRequest} publishedPackageTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferPublishedPackage(packageName: string, publishedPackageTransferRequest: PublishedPackageTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublishedPackageRegistry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferPublishedPackage(packageName, publishedPackageTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublishedPackagesApi.transferPublishedPackage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update published package visibility
         * @param {string} packageName 
         * @param {PublishedPackageVisibilityRequest} publishedPackageVisibilityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublishedPackageVisibility(packageName: string, publishedPackageVisibilityRequest: PublishedPackageVisibilityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublishedPackageRegistry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublishedPackageVisibility(packageName, publishedPackageVisibilityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublishedPackagesApi.updatePublishedPackageVisibility']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a published package archive
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPublishedPackage(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPublishedPackage(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublishedPackagesApi.uploadPublishedPackage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublishedPackagesApi - factory interface
 */
export const PublishedPackagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublishedPackagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete published package dist-tag
         * @param {string} packageName 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublishedPackageTag(packageName: string, tag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePublishedPackageTag(packageName, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download published package archive
         * @param {string} packageName 
         * @param {string} [version] Specific package version to retrieve. Defaults to the latest available version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPublishedPackage(packageName: string, version?: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadPublishedPackage(packageName, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Garbage collect published package versions
         * @param {PublishedPackageGcRequest} publishedPackageGcRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcPublishedPackages(publishedPackageGcRequest: PublishedPackageGcRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublishedPackageGcResult> {
            return localVarFp.gcPublishedPackages(publishedPackageGcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get published package detail
         * @param {string} packageName 
         * @param {string} [version] Specific package version to retrieve. Defaults to the latest available version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedPackage(packageName: string, version?: string, options?: RawAxiosRequestConfig): AxiosPromise<PackageDetail> {
            return localVarFp.getPublishedPackage(packageName, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get published package registry metadata
         * @param {string} packageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedPackageRegistry(packageName: string, options?: RawAxiosRequestConfig): AxiosPromise<PublishedPackageRegistry> {
            return localVarFp.getPublishedPackageRegistry(packageName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List published packages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublishedPackages(options?: RawAxiosRequestConfig): AxiosPromise<PackageList> {
            return localVarFp.listPublishedPackages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reserve a published package name
         * @param {string} packageName 
         * @param {PublishedPackageReserveRequest} [publishedPackageReserveRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservePublishedPackage(packageName: string, publishedPackageReserveRequest?: PublishedPackageReserveRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublishedPackageRegistry> {
            return localVarFp.reservePublishedPackage(packageName, publishedPackageReserveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set published package dist-tag
         * @param {string} packageName 
         * @param {string} tag 
         * @param {PublishedPackageTagRequest} publishedPackageTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublishedPackageTag(packageName: string, tag: string, publishedPackageTagRequest: PublishedPackageTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setPublishedPackageTag(packageName, tag, publishedPackageTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set published package version status
         * @param {string} packageName 
         * @param {string} version 
         * @param {PublishedPackageStatusRequest} publishedPackageStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublishedPackageVersionStatus(packageName: string, version: string, publishedPackageStatusRequest: PublishedPackageStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<PackageDetail> {
            return localVarFp.setPublishedPackageVersionStatus(packageName, version, publishedPackageStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer published package ownership
         * @param {string} packageName 
         * @param {PublishedPackageTransferRequest} publishedPackageTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferPublishedPackage(packageName: string, publishedPackageTransferRequest: PublishedPackageTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublishedPackageRegistry> {
            return localVarFp.transferPublishedPackage(packageName, publishedPackageTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update published package visibility
         * @param {string} packageName 
         * @param {PublishedPackageVisibilityRequest} publishedPackageVisibilityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublishedPackageVisibility(packageName: string, publishedPackageVisibilityRequest: PublishedPackageVisibilityRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublishedPackageRegistry> {
            return localVarFp.updatePublishedPackageVisibility(packageName, publishedPackageVisibilityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a published package archive
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPublishedPackage(file: File, options?: RawAxiosRequestConfig): AxiosPromise<PackageDetail> {
            return localVarFp.uploadPublishedPackage(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublishedPackagesApi - object-oriented interface
 */
export class PublishedPackagesApi extends BaseAPI {
    /**
     * 
     * @summary Delete published package dist-tag
     * @param {string} packageName 
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePublishedPackageTag(packageName: string, tag: string, options?: RawAxiosRequestConfig) {
        return PublishedPackagesApiFp(this.configuration).deletePublishedPackageTag(packageName, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download published package archive
     * @param {string} packageName 
     * @param {string} [version] Specific package version to retrieve. Defaults to the latest available version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadPublishedPackage(packageName: string, version?: string, options?: RawAxiosRequestConfig) {
        return PublishedPackagesApiFp(this.configuration).downloadPublishedPackage(packageName, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Garbage collect published package versions
     * @param {PublishedPackageGcRequest} publishedPackageGcRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public gcPublishedPackages(publishedPackageGcRequest: PublishedPackageGcRequest, options?: RawAxiosRequestConfig) {
        return PublishedPackagesApiFp(this.configuration).gcPublishedPackages(publishedPackageGcRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get published package detail
     * @param {string} packageName 
     * @param {string} [version] Specific package version to retrieve. Defaults to the latest available version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPublishedPackage(packageName: string, version?: string, options?: RawAxiosRequestConfig) {
        return PublishedPackagesApiFp(this.configuration).getPublishedPackage(packageName, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get published package registry metadata
     * @param {string} packageName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPublishedPackageRegistry(packageName: string, options?: RawAxiosRequestConfig) {
        return PublishedPackagesApiFp(this.configuration).getPublishedPackageRegistry(packageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List published packages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listPublishedPackages(options?: RawAxiosRequestConfig) {
        return PublishedPackagesApiFp(this.configuration).listPublishedPackages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reserve a published package name
     * @param {string} packageName 
     * @param {PublishedPackageReserveRequest} [publishedPackageReserveRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public reservePublishedPackage(packageName: string, publishedPackageReserveRequest?: PublishedPackageReserveRequest, options?: RawAxiosRequestConfig) {
        return PublishedPackagesApiFp(this.configuration).reservePublishedPackage(packageName, publishedPackageReserveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set published package dist-tag
     * @param {string} packageName 
     * @param {string} tag 
     * @param {PublishedPackageTagRequest} publishedPackageTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setPublishedPackageTag(packageName: string, tag: string, publishedPackageTagRequest: PublishedPackageTagRequest, options?: RawAxiosRequestConfig) {
        return PublishedPackagesApiFp(this.configuration).setPublishedPackageTag(packageName, tag, publishedPackageTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set published package version status
     * @param {string} packageName 
     * @param {string} version 
     * @param {PublishedPackageStatusRequest} publishedPackageStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setPublishedPackageVersionStatus(packageName: string, version: string, publishedPackageStatusRequest: PublishedPackageStatusRequest, options?: RawAxiosRequestConfig) {
        return PublishedPackagesApiFp(this.configuration).setPublishedPackageVersionStatus(packageName, version, publishedPackageStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer published package ownership
     * @param {string} packageName 
     * @param {PublishedPackageTransferRequest} publishedPackageTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transferPublishedPackage(packageName: string, publishedPackageTransferRequest: PublishedPackageTransferRequest, options?: RawAxiosRequestConfig) {
        return PublishedPackagesApiFp(this.configuration).transferPublishedPackage(packageName, publishedPackageTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update published package visibility
     * @param {string} packageName 
     * @param {PublishedPackageVisibilityRequest} publishedPackageVisibilityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePublishedPackageVisibility(packageName: string, publishedPackageVisibilityRequest: PublishedPackageVisibilityRequest, options?: RawAxiosRequestConfig) {
        return PublishedPackagesApiFp(this.configuration).updatePublishedPackageVisibility(packageName, publishedPackageVisibilityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a published package archive
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadPublishedPackage(file: File, options?: RawAxiosRequestConfig) {
        return PublishedPackagesApiFp(this.configuration).uploadPublishedPackage(file, options).then((request) => request(this.axios, this.basePath));
    }
}

