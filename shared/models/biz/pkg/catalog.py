# generated by datamodel-codegen:
#   filename:  pkg.catalog.schema.json

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel, constr


class Status(Enum):
    installed = 'installed'
    missing = 'missing'
    failed = 'failed'


class Adapter(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: str = Field(..., description='Unique adapter name within the package.')
    entrypoint: constr(
        pattern=r'^[A-Za-z_][A-Za-z0-9_.]*(?::[A-Za-z_][A-Za-z0-9_.]*)?$'
    ) = Field(..., description='Python module path containing adapter handlers.')
    capabilities: List[str] = Field(
        ...,
        description='Capabilities registered by this adapter (used for dispatch).',
        min_length=1,
    )
    description: Optional[str] = Field(None, description='Adapter level description.')
    idempotency: Optional[str] = Field(
        None, description='Idempotency guarantees of the adapter (e.g. per_request).'
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Additional adapter specific metadata.'
    )


class PythonConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    requires: str = Field(..., description='Python version requirement specifier.')
    dependencies: Optional[List[str]] = Field(
        [], description='Pip requirement specifiers installed during package setup.'
    )


class Status1(Enum):
    draft = 'draft'
    published = 'published'
    deprecated = 'deprecated'


class Mode(Enum):
    read = 'read'
    write = 'write'
    two_way = 'two_way'


class Kind(Enum):
    local = 'local'
    subgraph = 'subgraph'


class BindingScope(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kind: Optional[Kind] = Field(
        None, description='local = current workflow, subgraph = inline subgraph alias.'
    )
    subgraphAliases: Optional[List[str]] = Field(
        None,
        description='Ordered list of inline subgraph aliases traversed by the prefix.',
    )
    nodeId: Optional[str] = Field(
        None, description="Explicit target node identifier (used for '#node' prefixes)."
    )
    prefix: Optional[str] = Field(
        None,
        description='Raw prefix string captured before parsing (mirrors Binding.prefix).',
    )


class Resource(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    path: str = Field(..., description='Relative path to the bundled resource.')
    type: str = Field(
        ..., description='Resource type (download, archive, script, etc.).'
    )
    sha256: Optional[constr(pattern=r'^[A-Fa-f0-9]{64}$')] = Field(
        None, description='Optional checksum of the resource content.'
    )


class Hooks(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    install: Optional[List[str]] = Field(
        [], description='Scripts executed during install.'
    )
    uninstall: Optional[List[str]] = Field(
        [], description='Scripts executed during uninstall.'
    )


class Signature(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    sha256: Optional[constr(pattern=r'^[A-Fa-f0-9]{64}$')] = Field(
        None, description='SHA-256 hash of the archive or manifest.'
    )
    signedAt: Optional[str] = Field(
        None, description='Timestamp when the manifest was signed.'
    )
    signedBy: Optional[str] = Field(None, description='Identity of the signer.')


class JsonSchema(RootModel[Union[Dict[str, Any], bool]]):
    root: Union[Dict[str, Any], bool] = Field(
        ..., description='Embedded JSON Schema definition.'
    )


class Binding(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    path: str = Field(
        ..., description='JSON pointer style path targeted by the binding.'
    )
    mode: Optional[Mode] = Field(
        'write', description='Binding mode that describes read/write behaviour.'
    )
    prefix: Optional[str] = Field(
        None,
        description="Optional textual prefix (e.g. '@subgraphA.#nodeY') that scopes the binding before resolving the JSON pointer.",
    )
    scope: Optional[BindingScope] = None


class Port(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    key: str = Field(..., description='Stable identifier for the port.')
    label: str = Field(..., description='Display label for the port.')
    binding: Binding


class Widget(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    key: str = Field(..., description='Unique widget key.')
    label: str = Field(..., description='Widget label.')
    component: str = Field(..., description='Component type rendered by the dashboard.')
    binding: Binding
    options: Optional[Dict[str, Any]] = Field(
        None, description='Component options (schema depends on component).'
    )


class NodeUI(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    inputPorts: Optional[List[Port]] = []
    widgets: Optional[List[Widget]] = []
    outputPorts: Optional[List[Port]] = []


class Node(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: constr(pattern=r'^[A-Za-z0-9_.-]+$') = Field(
        ..., description='Fully qualified node type (package scoped).'
    )
    status: Status1 = Field(..., description='Lifecycle state of the node.')
    category: str = Field(
        ..., description='Grouping category displayed in the builder palette.'
    )
    label: str = Field(
        ..., description='Human readable label rendered in the palette and inspector.'
    )
    description: Optional[str] = Field(
        None, description='Extended description of the node behaviour.'
    )
    tags: Optional[List[str]] = Field(
        None, description='Free-form tags for searching/filtering.'
    )
    adapter: constr(pattern=r'^[A-Za-z0-9_.-]+$') = Field(
        ..., description='Adapter name responsible for the node implementation.'
    )
    handler: constr(pattern=r'^[A-Za-z_][A-Za-z0-9_]*$') = Field(
        ..., description='Handler callable exposed by the adapter.'
    )
    config: Optional[Dict[str, Any]] = Field(
        {}, description='Optional static configuration forwarded to the handler.'
    )
    schema_: JsonSchema = Field(
        ...,
        alias='schema',
        description='JSON Schema describing node parameters/results.',
    )
    ui: Optional[NodeUI] = None


class Manifest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    schemaVersion: constr(pattern=r'^[0-9]+\.[0-9]+\.[0-9]+$') = Field(
        ..., description='Manifest schema version (semver).'
    )
    name: constr(pattern=r'^[a-z0-9]+([._-][a-z0-9]+)*$') = Field(
        ..., description='Package identifier (lowercase with dots/underscores).'
    )
    version: constr(pattern=r'^[0-9]+\.[0-9]+\.[0-9]+(?:[-+][0-9A-Za-z.-]+)?$') = Field(
        ..., description='Package version in semver format.'
    )
    description: str = Field(..., description='Short summary of the package.')
    adapters: List[Adapter] = Field(
        ..., description='Adapter modules exposed by the package.', min_length=1
    )
    python: PythonConfig
    nodes: List[Node] = Field(
        ...,
        description='Node definitions surfaced to the builder and scheduler.',
        min_length=1,
    )
    resources: Optional[List[Resource]] = Field(
        [], description='Static assets bundled with the package.'
    )
    hooks: Optional[Hooks] = None
    signature: Optional[Signature] = None


class Package(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: constr(min_length=1)
    version: constr(min_length=1)
    status: Status
    source: Optional[str] = Field(
        None, description='Optional source identifier or URI.'
    )
    manifest: Manifest = Field(
        ...,
        description='Full package manifest definition (see docs/schema/manifest.json).',
    )
    metadata: Optional[Dict[str, Any]] = None


class PackageCatalog(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    packages: List[Package] = Field(
        ..., description='List of packages the sender can serve.'
    )
